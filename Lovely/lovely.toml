[manifest]
version = "1.0.0"
dump_lua = true
priority = 214748364



# Bullet King (1/3)
# Scored cards act as in hand
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
match_indent = true
position = 'after'
pattern = '''
card.lucky_trigger = nil
'''
payload = '''
local bullet_kings = SMODS.find_card('j_aij_bullet_king')
if next(bullet_kings) and context.cardarea == G.play and card:get_id() == 13 then
    context.cardarea = G.hand
    card.bullet_king = bullet_kings[1]
    SMODS.score_card(card, context)
    context.cardarea = G.play
end
'''
# Bullet King (2/3) 
# Scored cards trigger end of round in hand effects
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'after'
pattern = '''
hand_chips = mod_chips(nu_chip or hand_chips)
'''
payload = '''
local bullet_kings = SMODS.find_card('j_aij_bullet_king')
if next(bullet_kings) then
    All_in_Jest.bullet_king_end_of_round({cardarea = G.hand, end_of_round = true, beat_boss = G.GAME.blind.boss }, G.play.cards, bullet_kings[1])
end
'''
# Bullet King (3/3)
# Raised Fist compat
[[patches]]
[patches.pattern]
target = 'card.lua'
match_indent = true
position = 'before'
pattern = '''
if raised_card == context.other_card then 
'''
payload = '''
if next(SMODS.find_card('j_aij_bullet_king')) then
    for i=1, #G.play.cards do
        if temp_ID >= G.play.cards[i].base.id and not SMODS.has_no_rank(G.play.cards[i]) and card.bullet_king then 
            temp_Mult = G.play.cards[i].base.nominal
            temp_ID = G.play.cards[i].base.id
            raised_card = G.play.cards[i]
        end
    end
end
'''

# Overstuffed Tag (1/4)
# Card:open()
# Add triggers for overstuffed tags
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.opening = true"
position = "after"
match_indent = true
payload = '''
for i = #G.GAME.tags, 1, -1 do
    if G.GAME.tags[i]:apply_to_run({type = 'open_booster', booster = self}) then break end
end
'''

# Overstuffed Tag (2/4)
# Card:open()
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
for k, v in ipairs(pack_cards) do
    G.pack_cards:emplace(v)
end
'''
position = "before"
match_indent = true
payload = '''
SMODS.calculate_context({all_in_jest = {modify_booster_cards = true, card = self, before_added = true, pack_cards = pack_cards}})
'''
# Overstuffed Tag (3/4)
# Card:open()
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
for k, v in ipairs(pack_cards) do
    G.pack_cards:emplace(v)
end
'''
position = "after"
match_indent = true
payload = '''
SMODS.calculate_context({all_in_jest = {modify_booster_cards = true, card = self, pack_cards = pack_cards}})
'''

# Overstuffed tag (4/4) and similar effects
# Modify booster pack size
# Card:open()
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "local _size = *"
position = "after" 
match_indent = true
payload = '''
if G.GAME.jest_change_booster_options.trigger or G.GAME.jest_change_booster_options.pack_choices == "unlimited" then
    if G.GAME.jest_change_booster_options.option == "size" or G.GAME.jest_change_booster_options.option == "both" then
        -- Pemdas order
        if G.GAME.jest_change_booster_options.op.mult ~= 0 then
            _size = _size * G.GAME.jest_change_booster_options.op.mult
            G.GAME.jest_change_booster_options.op.mult = 0
        end
        if G.GAME.jest_change_booster_options.op.div ~= 0 then
            _size = _size / G.GAME.jest_change_booster_options.op.div
            G.GAME.jest_change_booster_options.op.div = 0
        end
        if G.GAME.jest_change_booster_options.op.add ~= 0 then
            _size = _size + G.GAME.jest_change_booster_options.op.add
            G.GAME.jest_change_booster_options.op.add = 0
        end
        if G.GAME.jest_change_booster_options.op.sub ~= 0 then
            _size = _size - G.GAME.jest_change_booster_options.op.sub
            G.GAME.jest_change_booster_options.op.sub = 0
        end
        G.GAME.jest_change_booster_options.option = ""
    end
    if G.GAME.jest_change_booster_options.pack_choices == "unlimited" then
        G.GAME.pack_choices = _size
        G.GAME.jest_change_booster_options.pack_choices = ""
    end
    G.GAME.jest_change_booster_options.trigger = false
end
'''

# Silver Cards (1/2)
# Resets attributes to pre-silver stats when card enhancements are removed
# Card:set_base()
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if delay_sprites == 'quantum' then self.from_quantum = true end"
position = "before"
match_indent = true
payload = '''
local aij_silver_reapply = false
if self.edition and self.edition.aij_silver then
    if old_center ~= center and (self.ability.set == 'Enhanced' or self.ability.set == 'Default') then
        jest_ability_calculate(
        self,
        "/", tonumber(self.edition.prevmult),
        { h_x_chips = 1, Xmult = 1, x_chips = 1, x_mult = 1, extra_value=true },
        nil, true, false, "ability"
        )
        aij_silver_reapply = true
    end
end
'''
# Silver Cards (2/2)
# Re-applies attributes to pre-silver stats when new enhancements are applied
# Card:set_base()
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = 'if not initial and delay_sprites ~= "quantum" and G.GAME.blind then G.GAME.blind:debuff_card(self) end'
position = "before"
match_indent = true
payload = '''
if self.edition and self.edition.aij_silver then
    if aij_silver_reapply and (self.ability.set == 'Enhanced' or self.ability.set == 'Default') then
        jest_ability_calculate(
        self,
        "*", self.edition.mult,
        { h_x_chips = 1, Xmult = 1, x_chips = 1, x_mult = 1, extra_value=true },
        nil, true, false, "ability"
        )
    end
end
'''

# Canvas Cards (1/3)
# Card:set_base()
# Removes canvas attributes when enhancement is removed
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if delay_sprites == 'quantum' then self.from_quantum = true end"
position = "before"
match_indent = true
payload = '''
if self.ability and SMODS.has_enhancement(self, 'm_aij_canvas') then
    if self.ability.aij_canvas_temp_suit and self.ability.aij_canvas_temp_rank and (self.ability.set == 'Enhanced' or self.ability.set == 'Default') then
        SMODS.change_base(self, self.ability.aij_canvas_temp_suit, self.ability.aij_canvas_temp_rank)
        self.front_hidden = self:should_hide_front()
        self.ability.aij_canvas_temp_suit = nil
        self.ability.aij_canvas_temp_rank = nil
    end
end
'''

# Canvas Cards (2/3)
# Card:generate_UIBox_ability_table()
# Set whether the front of a card is hidden so we know if we should hide card suit/rank badge
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "bonus_repetitions = *"
position = "after"
match_indent = true
payload = '''
front_hidden = self.front_hidden,
'''

# Canvas Cards (3/3)
# generate_card_ui()
# Removes name of card if canvas is blank
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "elseif specific_vars.playing_card then"
position = "before"
match_indent = true
payload = '''
elseif _c.key == 'm_aij_canvas' and specific_vars.front_hidden then full_UI_table.name = true
'''

# Suit Patches
# Card:is_suit()
# Makes cards treated as the suits they are patched with
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if SMODS.has_no_suit(self) then
    return false
end
'''
position = "before"
match_indent = true
payload = '''
if All_in_Jest.has_patches(self, suit) then
    return All_in_Jest.has_patches(self, suit)
end
'''

# Return to hand effects (e.g. Simulated Cards)
# G.FUNCS.draw_from_play_to_discard
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = "draw_card(G.play,G.discard, it*100/play_count,'down', false, v)"
position = "at"
payload = '''
local jest_to_hand = {}
            
if G.jokers ~= nil then
    for _, joker in ipairs(G.jokers.cards) do
        if joker.ability.extra and type(joker.ability.extra) == 'table' and joker.ability.extra.all_in_jest and joker.ability.extra.all_in_jest.to_hand and joker.ability.extra.all_in_jest.to_hand.cards and not joker.debuff then
            for __, card in ipairs(joker.ability.extra.all_in_jest.to_hand.cards) do
                table.insert(jest_to_hand, card)
            end
        end
    end
end

if G.play ~= nil then
    for _, play_card in ipairs(G.play.cards) do
        if play_card.ability.extra and type(play_card.ability.extra) == 'table' and play_card.ability.extra.all_in_jest and play_card.ability.extra.all_in_jest.to_hand and play_card.ability.extra.all_in_jest.to_hand.cards and not play_card.debuff then
            if play_card.ability.extra.all_in_jest.to_hand.cards == true then
                table.insert(jest_to_hand, play_card)
            end
        end
    end
end
            
if #jest_to_hand > 0 then
    local trigger = false
    for _, jest_to_hand in ipairs(jest_to_hand) do
        if v == jest_to_hand then
            trigger = true
        end
    end
    if trigger then
        draw_card(G.play,G.hand, it*100/play_count,'up', true, v)
    else
        draw_card(G.play,G.discard, it*100/play_count,'down', false, v)
    end
else
    draw_card(G.play,G.discard, it*100/play_count,'down', false, v)
end
'''
match_indent = true

# The Treachery Of Jokers going into Consumable slot instead
# Also make advanced copier jokers (joker.png, what's left, etc.) go into consumable slot if they're copying ToJ
# CardArea:emplace()
[[patches]] 
[patches.pattern]
target = "cardarea.lua"
pattern = '''
if location == 'front' or self.config.type == 'deck' then 
'''
position = "before"
payload = '''
if self == G.jokers then
    if card.config.center.key == 'j_aij_the_treachery_of_jokers' then
        self = G.consumeables
    end
    if card.ability[card.config.center.key] and card.ability[card.config.center.key].copied_joker_key == 'j_aij_the_treachery_of_jokers' then
        self = G.consumeables
    end
    if card.ability[card.config.center.key] and card.ability[card.config.center.key].copied_joker_abilities then
        local move = false
        local copier_ability = card.ability[card.config.center.key]
        for index = #copier_ability.copied_joker_abilities, math.max(1, #copier_ability.copied_joker_abilities - copier_ability.copy_limit + 1), -1 do
            local copied_ability = copier_ability.copied_joker_abilities[index]
            if copied_ability.key == "j_aij_the_treachery_of_jokers" then
                move = true
                break
            end
        end
        if move then
            self = G.consumeables
        end
    end
end
'''
match_indent = true

# Add context for when cards are drawn to hand
# Usually for effects that happen at the start of the round and after a hand is played but did not win
# G.FUNCS.play_cards_from_highlighted()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = "G.GAME.hands_played = G.GAME.hands_played + 1"
position = "before"
payload = '''
SMODS.calculate_context({all_in_jest = {drew_cards = true}})
'''
match_indent = true

# Ice Cards (1/4)
# Force Ice Cards to always be selectable
# CardArea:can_highlight()
[[patches]] 
[patches.pattern]
target = "cardarea.lua"
pattern = '''
if G.CONTROLLER.HID.controller then
'''
position = "before"
payload = '''
if self.config.type == 'hand' then
    if SMODS.get_enhancements(card).m_aij_ice and not card.debuff then
        return true
    end
end
'''
match_indent = true

# Ice Cards (2/4)
# Force Ice Cards to always be selectable
# CardArea:can_highlight()
[[patches]] 
[patches.pattern]
target = "cardarea.lua"
pattern = '''
if #self.highlighted >= self.config.highlighted_limit then
    card:highlight(false)
else
    self.highlighted[#self.highlighted+1] = card
    card:highlight(true)
    if not silent then play_sound('cardSlide1') end
end
'''
position = "after"
payload = '''
local ice = {}
for k, v in pairs(self.highlighted) do
    if SMODS.get_enhancements(self.highlighted[k]).m_aij_ice and not self.highlighted[k].debuff then
        ice[#ice+1] = v
    end
end
if not card.highlighted and #ice >= 1 then
    if (#self.highlighted - #ice) >= self.config.highlighted_limit then
        card:highlight(false)
    else
        self.highlighted[#self.highlighted+1] = card
        card:highlight(true)
        if not silent then play_sound('cardSlide1') end
    end
end
if (SMODS.get_enhancements(card).m_aij_ice) and not card.debuff and not card.highlighted then
    self.highlighted[#self.highlighted+1] = card
    card:highlight(true)
    if not silent then play_sound('cardSlide1') end
end
'''
match_indent = true

# Ice Cards (3/4)
# Exclude ice cards that exceed hand limit from determining in hand type
# evaluate_poker_hand()
[[patches]] 
[patches.pattern]
target = '=[SMODS _ "src/overrides.lua"]'
pattern = "for _, v in ipairs(SMODS.PokerHandPart.obj_buffer) do"
position = "before"
payload = '''
do -- All in Jest, determining which ice cards count in the hand type
    local ice = {}
    local non_ice = {}
    for k, v in pairs(hand) do
        if SMODS.get_enhancements(hand[k]).m_aij_ice and not hand[k].debuff then
            ice[#ice+1] = v
        else
            non_ice[#non_ice+1] = v
        end
    end
    if #ice > 0 then
        hand = {}
        local temp_jest_var = 0
        for k, v in pairs(non_ice) do
            hand[temp_jest_var+1] = v
            temp_jest_var = temp_jest_var + 1
        end
        for k, v in pairs(ice) do
            if (math.max(G.GAME.starting_params.play_limit, 1) - temp_jest_var) > 0 then
                hand[temp_jest_var+1] = v
                temp_jest_var = temp_jest_var + 1
            end
        end
    end
end
'''
match_indent = true

# Ice Cards (4/4) + Marked Cards (1/3)
# Make play button active regardless of if ice cards exceed limit
# Make play button disabled if any selected card is marked
# G.FUNCS.can_play()
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "if #G.hand.highlighted <= 0 or G.GAME.blind.block_play or #G.hand.highlighted > math.max(G.GAME.starting_params.play_limit, 1) then"
position = "before"
payload = '''
do
    local aij_exceeds_hand_limit = 0
    for k, v in pairs(G.hand.highlighted) do
        if v.ability.aij_marked then
            e.config.colour = G.C.UI.BACKGROUND_INACTIVE
            e.config.button = nil
            return
        end
        if SMODS.get_enhancements(v).m_aij_ice and not v.debuff then
            aij_exceeds_hand_limit = aij_exceeds_hand_limit + 1
        end
    end
    if aij_exceeds_hand_limit > 0 and not ((#G.hand.highlighted - aij_exceeds_hand_limit) > math.max(G.GAME.starting_params.play_limit, 1) or G.GAME.blind.block_play or #G.hand.highlighted <= 0) then
        e.config.colour = G.C.BLUE
        e.config.button = 'play_cards_from_highlighted'
        return
    end
end
'''
match_indent = true

# Marked Cards (2/3)
# Make discard button disabled if any selected card is marked
# G.FUNCS.can_discard()
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''
e.config.colour = G.C.RED
e.config.button = 'discard_cards_from_highlighted'
'''
position = "at"
payload = '''
local aij_can_discard = false
for k, v in pairs(G.hand.highlighted) do
    if v.ability.aij_marked then
        aij_can_discard = true
    end
end
if aij_can_discard then
    e.config.colour = G.C.UI.BACKGROUND_INACTIVE
    e.config.button = nil
else
    e.config.colour = G.C.RED
    e.config.button = 'discard_cards_from_highlighted'
end
'''
match_indent = true

# Marked Cards (3/3)
# Ends the round if all cards in hand are marked (resulting in a game over)
# SMODS.draw_cards
[[patches]] 
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = "local flags = SMODS.calculate_context({drawing_cards = true, amount = hand_space})"
position = "before"
payload = '''
local marked_cards = 0
for k, v in pairs(G.hand.cards) do
    if v.ability.aij_marked then
        marked_cards = marked_cards + 1
    end
end
if marked_cards == #G.hand.cards and marked_cards >= G.hand.config.card_limit then
    end_round()
end
'''
match_indent = true

# Adds a context used to modify the hand type that was played
# G.FUNCS.evaluate_play()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
local text,disp_text,poker_hands,scoring_hand,non_loc_disp_text = G.FUNCS.get_poker_hand_info(G.play.cards)
'''
position = "before"
payload = '''
local fake_text,fake_disp_text,fake_poker_hands,fake_scoring_hand,fake_non_loc_disp_text = G.FUNCS.get_poker_hand_info(G.play.cards)
SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = fake_scoring_hand, scoring_name = fake_text, poker_hands = fake_poker_hands, aij_before_before = true})
'''
match_indent = true

# Royal Flush (1/5) + Corndog (1/1)
# Add stats to the royal flush when its played
# G.FUNCS.evaluate_play()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
G.GAME.hands[text].played = G.GAME.hands[text].played + 1
'''
position = "before"
payload = '''
if next(SMODS.find_card("j_aij_corndog")) then 
    text = 'Straight Flush'
    non_loc_disp_text = text
    disp_text = localize(text, 'poker_hands')
    if poker_hands and scoring_hand and not next(poker_hands["Straight Flush"]) then
        table.insert(poker_hands["Straight Flush"], scoring_hand)
    end
end
local calculated_text = nil
if text == 'aij_Royal Flush' then
    calculated_text = 'aij_Royal Flush'
    G.GAME.hands[calculated_text].played = G.GAME.hands[calculated_text].played + 1
    G.GAME.hands[calculated_text].played_this_round = G.GAME.hands[calculated_text].played_this_round + 1
    G.GAME.last_hand_played = calculated_text
    set_hand_usage(calculated_text)
    text = 'Straight Flush'
end
'''
match_indent = true

# Royal Flush (2/5)
# Gives the Royal Flush chips and mult when played (instead of a straight flush)
# G.FUNCS.evaluate_play()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
mult = mod_mult(G.GAME.hands[text].mult)
hand_chips = mod_chips(G.GAME.hands[text].chips)
'''
position = "at"
payload = '''
mult = mod_mult(G.GAME.hands[calculated_text or text].mult)
hand_chips = mod_chips(G.GAME.hands[calculated_text or text].chips)
'''
match_indent = true

# Royal Flush (3/5)
# Show the Royal Flush chips and mult when played (instead of a straight flush)
# G.FUNCS.evaluate_play()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
update_hand_text({sound = G.GAME.current_round.current_hand.handname ~= disp_text and 'button' or nil, volume = 0.4, immediate = true, nopulse = nil,
            delay = G.GAME.current_round.current_hand.handname ~= disp_text and 0.4 or 0}, {handname=disp_text, level=G.GAME.hands[text].level, mult = G.GAME.hands[text].mult, chips = G.GAME.hands[text].chips})
'''
position = "at"
payload = '''
update_hand_text({sound = G.GAME.current_round.current_hand.handname ~= disp_text and 'button' or nil, volume = 0.4, immediate = true, nopulse = nil,
            delay = G.GAME.current_round.current_hand.handname ~= disp_text and 0.4 or 0}, {handname=disp_text, level=G.GAME.hands[calculated_text or text].level, mult = G.GAME.hands[calculated_text or text].mult, chips = G.GAME.hands[calculated_text or text].chips})
'''
match_indent = true

# Royal Flush (4/5)
# Show the Royal Flush chips and mult when played (instead of a straight flush)
# G.FUNCS.evaluate_play()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
SMODS.displayed_hand = text
'''
position = "after"
payload = '''
SMODS.displayed_hand = calculated_text or text
'''
match_indent = true

# Royal Flush (5/5)
# Show the level of royal flush and additional chips+mult in run info
# create_UIBox_hand_tip()
[[patches]] 
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''
return {n=G.UIT.R, config={align = "cm", colour = G.C.WHITE, r = 0.1}, nodes={
'''
position = "before"
payload = '''
if handname == 'Straight Flush' and G.GAME.hands["aij_Royal Flush"] and G.GAME.hands["aij_Royal Flush"].level > G.GAME.hands["Straight Flush"].level then
    return {n=G.UIT.R, config={align = "cm", r = 0.1}, nodes={
        {n=G.UIT.R, config={align = "cm", colour = G.C.WHITE, r = 0.1}, nodes={
          {n=G.UIT.C, config={align = "cm"}, nodes={
            {n=G.UIT.O, config={object = cardarea}}
          }}
        }},
        {n=G.UIT.R, config={align = "cm", padding = 0.05, r = 0.1, colour = darken(G.C.JOKER_GREY, 0.1), emboss = 0.05, hover = true, force_focus = true, on_demand_tooltip = {text = localize("aij_Royal Flush", 'poker_hand_descriptions'), filler = {func = create_UIBox_hand_tip, args = "aij_Royal Flush"}}}, nodes={
          {n=G.UIT.C, config={align = "cl", padding = 0, minw = 5}, nodes={
            {n=G.UIT.C, config={align = "cm", padding = 0.01, r = 0.1, colour = G.C.HAND_LEVELS[math.min(7, math.max(G.GAME.hands["aij_Royal Flush"].level-G.GAME.hands["Straight Flush"].level))], minw = 1.5, outline = 0.8, outline_colour = G.C.WHITE}, nodes={
              {n=G.UIT.T, config={text = '+'..localize('k_level_prefix')..(G.GAME.hands["aij_Royal Flush"].level-G.GAME.hands["Straight Flush"].level), scale = 0.5, colour = G.C.UI.TEXT_DARK}}
            }},
            {n=G.UIT.C, config={align = "cm", minw = 4.5, maxw = 4.5}, nodes={
              {n=G.UIT.T, config={text = ' '..localize("aij_Royal Flush",'poker_hands'), scale = 0.45, colour = G.C.UI.TEXT_LIGHT, shadow = true}}
            }}
          }},
          {n=G.UIT.C, config={align = "cm", padding = 0.05, colour = G.C.BLACK,r = 0.1}, nodes={
            {n=G.UIT.C, config={align = "cr", padding = 0.01, r = 0.1, colour = G.C.CHIPS, minw = 1.1}, nodes={
              {n=G.UIT.T, config={text = '+'..number_format(G.GAME.hands["aij_Royal Flush"].chips-G.GAME.hands["Straight Flush"].chips, 1000000), scale = 0.45, colour = G.C.UI.TEXT_LIGHT}},
              {n=G.UIT.B, config={w = 0.08, h = 0.01}}
            }},
            {n=G.UIT.T, config={text = "X", scale = 0.45, colour = G.C.MULT}},
            {n=G.UIT.C, config={align = "cl", padding = 0.01, r = 0.1, colour = G.C.MULT, minw = 1.1}, nodes={
              {n=G.UIT.B, config={w = 0.08,h = 0.01}},
              {n=G.UIT.T, config={text = '+'..number_format(G.GAME.hands["aij_Royal Flush"].mult-G.GAME.hands["Straight Flush"].mult, 1000000), scale = 0.45, colour = G.C.UI.TEXT_LIGHT}}
            }}
          }},
          {n=G.UIT.C, config={align = "cm"}, nodes={
              {n=G.UIT.T, config={text = '  #', scale = 0.45, colour = G.C.UI.TEXT_LIGHT, shadow = true}}
            }},
          {n=G.UIT.C, config={align = "cm", padding = 0.05, colour = G.C.L_BLACK,r = 0.1, minw = 0.9}, nodes={
            {n=G.UIT.T, config={text = G.GAME.hands["aij_Royal Flush"].played, scale = 0.45, colour = G.C.FILTER, shadow = true}},
          }}
        }},
    }}
end
'''
match_indent = true

#################################
    # PATCHES FOR NEW DECKS #
#################################
# (And also one related to Gold Trophy)

# Fabled Deck (1/3)
# Randomise if created joker should be a legendary joker or not
# get_current_pool()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
if _type == 'Joker' then 
'''
position = "before"
match_indent = true
payload = '''
if G.GAME.jest_legendary_pool ~= nil and _type == 'Joker' then
    if G.GAME.jest_legendary_pool.in_shop then
        local rary = _rarity or pseudorandom('rarity'..G.GAME.round_resets.ante..(_append or '')) 
        if type(rary) == "number" and (_rarity == nil or _rarity == 4 or _rarity == "Legendary") then
            rary = (rary > G.GAME.jest_legendary_pool.rate and 4) or 1 
            if rary ~= 1 then
                _legendary = true
            end
        end
    end
end
'''

# Fabled Deck (2/3)
# Make legendary jokers in the shop show their description
# Card:generate_UIBox_ability_table()
[[patches]]
[patches.regex]
target = "card.lua"
pattern = '''
(?<indent>[\t ]*)if self\.config\.center\.unlocked == false and not self\.bypass_lock (?<post>.*)
'''
position = "at"
line_prepend = '$indent'
payload = '''
if self.config.center.unlocked == false and not self.bypass_lock and not self.bypass_discovery_ui $post
'''

# Fabled Deck (3/3)
# Unlocks card if legendary joker is obtained in any way
# (In Vanilla, only unlocks via Soul)
# Card:add_to_deck()
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "function Card:add_to_deck(*"
position = "after"
match_indent = true
payload = '''
    if not self.config.center.unlocked and self.config.center.rarity == 4 then
        unlock_card(self.config.center)
    end
'''

# Patchwork deck (1/1)
# Set all cards in all cardareas to contain a patch
# Game:update()
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "for k, v in pairs(self.ANIMATIONS) do"
position = "before"
match_indent = true
payload = '''
if (G.GAME.selected_back and G.GAME.selected_back.name == 'b_aij_patchwork') or (G.GAME.selected_sleeve and G.GAME.selected_sleeve == 'sleeve_aij_patchwork') then
    if G then
        for k, v in pairs(G) do
            if G[k] and type(G[k]) == 'table' and G[k].cards then
                for _, cur_card in pairs(G[k].cards) do
                    if cur_card.ability and not cur_card.ability.patches and cur_card.ability.set and (cur_card.ability.set == 'Default' or cur_card.ability.set == 'Enhanced') then
                        local keys = {}
		                    for key, val in pairs(SMODS.Suits) do
                            if val.in_pool and val.in_pool(val, nil) then
                                keys[#keys+1] = key
                            elseif not val.in_pool then
			                          keys[#keys+1] = key
                            end
		                    end
		                    local cur_suit = pseudorandom_element(keys, pseudoseed('patchwork'))
                        local temp_index = 0
                        while cur_suit == cur_card.base.suit do
                            cur_suit = pseudorandom_element(keys, pseudoseed('patchwork_resample'..temp_index))
                            temp_index = temp_index + 1
                        end
			                  All_in_Jest.add_patch(cur_card, cur_suit, true);
                        if (G.GAME.selected_back and G.GAME.selected_back.name == 'b_aij_patchwork') and (G.GAME.selected_sleeve and G.GAME.selected_sleeve == 'sleeve_aij_patchwork') then
                            local keys = {}
		                        for key, val in pairs(SMODS.Suits) do
                                if val.in_pool and val.in_pool(val, nil) then
                                    keys[#keys+1] = key
                                elseif not val.in_pool then
			                              keys[#keys+1] = key
                                end
                            end
		                        local cur_suit = pseudorandom_element(keys, pseudoseed('patchwork'))
                            local temp_index = 0
                            while cur_suit == cur_card.base.suit or cur_card.ability.patches[cur_suit] do
                                cur_suit = pseudorandom_element(keys, pseudoseed('patchwork_resample'..temp_index))
                                temp_index = temp_index + 1
                            end
			                      All_in_Jest.add_patch(cur_card, cur_suit, true);
                        end
                    end
                end
            end
        end
    end
end
'''

# Branching Deck (1/9)
# Create UI for the three tag choices
# create_UIBox_blind_tag()
[[patches]] 
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''
_tag_sprite.states.collide.can = not not run_info
'''
position = "after"
payload = '''
local jest_tag_nodes = {}
local jest_tag_sprites = {}
local jest_tag_info = {}
if G.GAME.all_in_jest.blind_tags.has_multiple and G.GAME.all_in_jest.blind_tags.amt > 1 then
    local temp_index = 0
    for i = 1, G.GAME.all_in_jest.blind_tags.amt do
        if amt == 1 then
            jest_tag_info[#jest_tag_info+1] = _tag
            jest_tag_sprites[#jest_tag_sprites+1] = _tag_sprite
            jest_tag_nodes[#jest_tag_nodes+1] = {n=G.UIT.C, config={id = 'tag_desc', align = "cm", minh = 1, hover = true, button = 'All_in_Jest_select_tag', func = 'aij_hover_tag_branching', ref_table = {i, _tag}}, nodes={ _tag_ui }}
        else
            G.GAME.all_in_jest.blind_tags[blind_choice] = G.GAME.all_in_jest.blind_tags[blind_choice] or {}
            local jest_temp_tag = G.GAME.all_in_jest.blind_tags[blind_choice][i]
            if not jest_temp_tag then
                if i == 1 then -- Leftmost tag matches vanilla skip tag
                    G.GAME.all_in_jest.blind_tags[blind_choice][i] = G.GAME.round_resets.blind_tags[blind_choice]
                else
                    local temp_index_two = 0
                    G.GAME.all_in_jest.blind_tags[blind_choice][i] = get_next_tag_key()
                    while G.GAME.all_in_jest.blind_tags[blind_choice][i] == G.GAME.round_resets.blind_tags[blind_choice] do
                        temp_index_two = temp_index_two + 1
                        G.GAME.all_in_jest.blind_tags[blind_choice][i] = get_next_tag_key('_resample_'..temp_index_two)
                    end
                end
                jest_temp_tag = G.GAME.all_in_jest.blind_tags[blind_choice][i]
            end
            local _tag_2 = Tag(jest_temp_tag, nil, blind_choice)
            local _tag_ui_2, _tag_sprite_2 = _tag_2:generate_UI()
            _tag_sprite_2.states.collide.can = not not run_info
            jest_tag_info[#jest_tag_info+1] = _tag_2
            jest_tag_sprites[#jest_tag_sprites+1] = _tag_sprite_2
            jest_tag_nodes[#jest_tag_nodes+1] = {n=G.UIT.C, config={id = 'tag_desc', align = "cm", minh = 1, hover = true, button = 'All_in_Jest_select_tag', func = 'aij_hover_tag_branching', ref_table = {i, _tag_2}}, nodes={ _tag_ui_2 }}
        end
    end
end
'''
match_indent = true

# Branching Deck (2/9)
# Apply the three tag choices to the blind select screen
# create_UIBox_blind_tag()
[[patches]] 
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''
{n=G.UIT.R, config={id = 'tag_'..blind_choice, align = "cm", r = 0.1, padding = 0.1, minw = 1, can_collide = true, ref_table = _tag_sprite}, nodes={
'''
position = "before"
payload = '''
G.GAME.all_in_jest.blind_tags.has_multiple and G.GAME.all_in_jest.blind_tags.amt > 1 and {n=G.UIT.R, config={id = 'tag_'..blind_choice, align = "cm", r = 0.1, padding = 0.1, minw = 1, can_collide = true, ref_table = jest_tag_sprites}, nodes={
        {n=G.UIT.R, config={align = "cm", r = 0.1, maxw = 1}, nodes=jest_tag_nodes},
        not run_info and {n=G.UIT.R, config={align = "cm", colour = G.C.UI.BACKGROUND_INACTIVE, minh = 0.8, minw = 2, maxw = 2, padding = 0.07, r = 0.1, shadow = true, hover = true, one_press = true, button = 'skip_blind', func = 'hover_tag_proxy', ref_table = jest_tag_info}, nodes={
            {n=G.UIT.T, config={text = localize('b_skip_blind'), scale = 0.4, colour = G.C.UI.TEXT_INACTIVE}}
        }} or {n=G.UIT.R, config={align = "cm", padding = 0.1, emboss = 0.05, colour = mix_colours(G.C.BLUE, G.C.BLACK, 0.4), r = 0.1, maxw = 2}, nodes={
            {n=G.UIT.T, config={text = localize('b_skip_reward'), scale = 0.35, colour = G.C.WHITE}},
        }},
    }} or
'''
match_indent = true

# Branching Deck (3/9)
# G.FUNCS.blind_choice_handler()
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "if not e.config.ref_table.run_info and G.blind_select and G.blind_select.VT.y < 10 and e.config.id and G.blind_select_opts[string.lower(e.config.id)] then"
position = "before"
payload = '''
-- All in Jest patch
if G.GAME.all_in_jest.blind_tags.has_multiple and G.GAME.all_in_jest.blind_tags.amt > 1 then
    if not e.config.ref_table.run_info and G.blind_select and G.blind_select.VT.y < 10 and e.config.id and G.blind_select_opts[string.lower(e.config.id)] then 
      if e.UIBox.role.xy_bond ~= 'Weak' then e.UIBox:set_role({xy_bond = 'Weak'}) end
      if (e.config.ref_table.deck ~= 'on' and e.config.id == G.GAME.blind_on_deck) or
         (e.config.ref_table.deck ~= 'off' and e.config.id ~= G.GAME.blind_on_deck) then

          local _blind_choice = G.blind_select_opts[string.lower(e.config.id)]
          local _top_button = e.UIBox:get_UIE_by_ID('select_blind_button')
          local _border = e.UIBox.UIRoot.children[1].children[1]
          local _tag = e.UIBox:get_UIE_by_ID('tag_'..e.config.id)
          local _tag_container = e.UIBox:get_UIE_by_ID('tag_container')
          if _tag_container and not G.SETTINGS.tutorial_complete and not G.SETTINGS.tutorial_progress.completed_parts['shop_1'] then _tag_container.states.visible = false
          elseif _tag_container then  _tag_container.states.visible = true end
          if e.config.id == G.GAME.blind_on_deck then
            e.config.ref_table.deck = 'on'
            e.config.draw_after = false
            e.config.colour = G.C.CLEAR
            _border.parent.config.outline = 2
            _border.parent.config.outline_colour = G.C.UI.TRANSPARENT_DARK
            _border.config.outline_colour = _border.config.outline and _border.config.outline_colour or get_blind_main_colour(e.config.id)
            _border.config.outline = 1.5
            _blind_choice.alignment.offset.y = -0.9
            if _tag and _tag_container then 
              _tag_container.children[2].config.draw_after = false
              _tag_container.children[2].config.colour = G.C.BLACK
              _tag.config.outline_colour = adjust_alpha(G.C.BLUE, 0.5)
              _tag.children[2].config.button = nil
              _tag.children[2].config.hover = false
              _tag.children[2].config.colour = G.C.UI.BACKGROUND_INACTIVE
              _tag.children[2].children[1].config.colour = G.C.UI.TEXT_INACTIVE
              for i = 1, #_tag.children[1].children do
                local _sprite = _tag.config.ref_table[i]
                _sprite.config.force_focus = nil
                _tag.children[1].children[i].config.button = 'All_in_Jest_select_tag'
              end
            end
            if _top_button then
              G.E_MANAGER:add_event(Event({func = function()
                G.CONTROLLER:snap_to({node = _top_button})
              return true end }))
              if _top_button.config.button ~= "mp_toggle_ready" then -- AiJ x Multiplayer
                  _top_button.config.button = "select_blind"
              end
              _top_button.config.colour = G.C.FILTER
              _top_button.config.hover = true
              _top_button.children[1].config.colour = G.C.WHITE
            end
          elseif e.config.id ~= G.GAME.blind_on_deck then 
            e.config.ref_table.deck = 'off'
            e.config.draw_after = true
            e.config.colour = adjust_alpha(G.GAME.round_resets.blind_states[e.config.id] == 'Skipped' and mix_colours(G.C.BLUE, G.C.L_BLACK, 0.1) or G.C.L_BLACK, 0.5)
            _border.parent.config.outline = nil
            _border.parent.config.outline_colour = nil
            _border.config.outline_colour = nil
            _border.config.outline = nil
            _blind_choice.alignment.offset.y = -0.2
            if _tag and _tag_container then 
              if G.GAME.round_resets.blind_states[e.config.id] == 'Skipped' or
                 G.GAME.round_resets.blind_states[e.config.id] == 'Defeated' then
                _tag_container.children[2]:set_role({xy_bond = 'Weak'})
                _tag_container.children[2]:align(0, 10)
                _tag_container.children[1]:set_role({xy_bond = 'Weak'})
                _tag_container.children[1]:align(0, 10)
              end
              if G.GAME.round_resets.blind_states[e.config.id] == 'Skipped' then
                _blind_choice.children.alert = UIBox{
                  definition = create_UIBox_card_alert({text_rot = -0.35, no_bg = true,text = localize('k_skipped_cap'), bump_amount = 1, scale = 0.9, maxw = 3.4}),
                  config = {
                    align="tmi",
                    offset = {x = 0, y = 2.2},
                    major = _blind_choice, parent = _blind_choice}
                }
              end
              _tag.children[2].config.button = nil
              _tag.config.outline_colour = G.C.UI.BACKGROUND_INACTIVE
              _tag.children[2].config.hover = false
              _tag.children[2].config.colour = G.C.UI.BACKGROUND_INACTIVE
              _tag.children[2].children[1].config.colour = G.C.UI.TEXT_INACTIVE
              for i = 1, #_tag.children[1].children do
                _tag.children[1].children[i].config.button = nil
                local _sprite = _tag.config.ref_table[i]
                _sprite.config.force_focus = true
              end
            end
            if _top_button then 
              _top_button.config.colour = G.C.UI.BACKGROUND_INACTIVE
              _top_button.config.button = nil
              _top_button.config.hover = false
              _top_button.children[1].config.colour = G.C.UI.TEXT_INACTIVE
            end
          end
      end
    end
    return
end
-- End of All in Jest patch
'''
match_indent = true

# Branching Deck (4/9)
# Creates the popup of the selected tag when overing over the button
# Popup when hovering over the tag itself is handled seperately in the G.FUNCS.aij_hover_tag_branching() function (in functions.lua)
# G.FUNCS.hover_tag_proxy()
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "if (e.states.hover.is or e.parent.states.hover.is) and (e.created_on_pause == G.SETTINGS.paused) and"
position = "before"
payload = '''
-- All in Jest patch
if G.GAME.all_in_jest.blind_tags.has_multiple and G.GAME.all_in_jest.blind_tags.amt > 1 then
    if e.states.hover.is and (e.created_on_pause == G.SETTINGS.paused) and not e.alert and G.GAME.all_in_jest.blind_tags.selected_index and e.parent.config.id == 'tag_'..G.GAME.blind_on_deck then
      local _sprite = e.config.ref_table[G.GAME.all_in_jest.blind_tags.selected_index]:get_uibox_table()
      e.alert = UIBox{
          definition = G.UIDEF.card_h_popup(_sprite),
          config = {align="tm", offset = {x = 0, y = -0.1},
          major = e.parent,
          instance_type = 'POPUP'},
      }
      _sprite:juice_up(0.05, 0.02)
      play_sound('paper1', math.random()*0.1 + 0.55, 0.42)
      play_sound('tarot2', math.random()*0.1 + 0.55, 0.09)
      e.alert.states.collide.can = false
    elseif e.alert and (not e.states.collide.is or e.created_on_pause ~= G.SETTINGS.paused) then
          e.alert:remove()
          e.alert = nil
    end
    if e.parent.config.id == 'tag_'..G.GAME.blind_on_deck and G.GAME.all_in_jest.blind_tags.selected_index then
        e.config.button = 'skip_blind'
        e.config.hover = true
        e.config.colour = G.C.RED
        if e.children[1] then
            e.children[1].config.colour = G.C.UI.TEXT_LIGHT
        end
    else  
        e.config.button = nil
        e.config.hover = false
        e.config.colour = G.C.UI.BACKGROUND_INACTIVE
        if e.children[1] then
            e.children[1].config.colour = G.C.UI.TEXT_INACTIVE
        end
    end
    return
end
-- End of All in Jest patch
'''
match_indent = true

# Branching Deck (5/9)
# Reset selected tag when exiting the shop
# G.FUNCS.toggle_shop
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "SMODS.calculate_context({ending_shop = true})"
position = "after"
payload = '''
G.GAME.all_in_jest.blind_tags.selected_index = nil
'''
match_indent = true

# Branching Deck (6/9)
# Reset selected tag when ending the blind (needed for Dizzard)
# Wildcard for compat with multiplayer
# G.FUNCS.cash_out()
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "G.deck:shuffle('cashout'..*"
position = "after"
payload = '''
G.GAME.all_in_jest.blind_tags.selected_index = nil
'''
match_indent = true

# Branching Deck (7/9)
# Grant the selected tag when skipping the blind
# G.FUNCS.cash_out()
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "G.GAME.skips = (G.GAME.skips or 0) + 1"
position = "after"
payload = '''
check_for_unlock({type = 'skip_count'})
if G.GAME.all_in_jest.blind_tags.has_multiple and G.GAME.all_in_jest.blind_tags.amt > 1 then
    _tag = e.UIBox:get_UIE_by_ID('tag_'..G.GAME.blind_on_deck)
    if _tag then 
      add_tag(_tag.children[2].config.ref_table[G.GAME.all_in_jest.blind_tags.selected_index])
      G.GAME.all_in_jest.blind_tags.selected_index = nil
      local skipped, skip_to = G.GAME.blind_on_deck or 'Small', 
      G.GAME.blind_on_deck == 'Small' and 'Big' or G.GAME.blind_on_deck == 'Big' and 'Boss' or 'Boss'
      G.GAME.round_resets.blind_states[skipped] = 'Skipped'
      G.GAME.round_resets.blind_states[skip_to] = 'Select'
      G.GAME.blind_on_deck = skip_to
      play_sound('generic1')
      G.E_MANAGER:add_event(Event({
        trigger = 'immediate',
        func = function()
          delay(0.3)
          SMODS.calculate_context({skip_blind = true})
          save_run()
          for i = 1, #G.GAME.tags do
            G.GAME.tags[i]:apply_to_run({type = 'immediate'})
          end
          for i = 1, #G.GAME.tags do
            if G.GAME.tags[i]:apply_to_run({type = 'new_blind_choice'}) then break end
          end
          return true
        end
      }))
    end
    return
end
'''
match_indent = true

# Branching Deck (8/9)
# Defines the skip tag choices for the first ante at the start of the run (there is another patch that handles it for future antes)
# Game:start_run()
[[patches]] 
[patches.pattern]
target = "game.lua"
pattern = "self.GAME.round_resets.blind_tags.Big = G.SETTINGS.tutorial_progress and G.SETTINGS.tutorial_progress.forced_tags and G.SETTINGS.tutorial_progress.forced_tags[2] or get_next_tag_key()"
position = "after"
payload = '''
for k, v in pairs(self.GAME.round_resets.blind_tags) do
    self.GAME.all_in_jest.blind_tags[k] = self.GAME.all_in_jest.blind_tags[k] or {}
    local temp_index = 0
    for i = 1, self.GAME.all_in_jest.blind_tags.amt do
        if i == 1 then -- Leftmost tag matches vanilla skip tag
            self.GAME.all_in_jest.blind_tags[k][i] = v
        else
            self.GAME.all_in_jest.blind_tags[k][i] = get_next_tag_key()
            while self.GAME.all_in_jest.blind_tags[k][i] == v do
                temp_index = temp_index + 1
                self.GAME.all_in_jest.blind_tags[k][i] = get_next_tag_key('_resample_'..temp_index)
            end
        end
    end
    pseudoshuffle(self.GAME.all_in_jest.blind_tags[k], pseudoseed('aij_branching')) -- So leftmost tag isn't always the "vanilla" choice
end
'''
match_indent = true

# Golden Trophy (1/1) + Branching Deck (9/9)
# Sets big blind tag to gold if Golden Trophy activates
# Defines the skip tag choices for next ante (there is another patch that handles it at the start of the game)
# G.FUNCS.cash_out()
# Keeping this in one patch because the order of effects here is important
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "G.GAME.round_resets.blind_tags.Big = get_next_tag_key()"
position = "after"
payload = '''
if G.GAME.used_vouchers.v_aij_trophy and G.GAME.all_in_jest.apply.v_aij_trophy_chance then
    G.GAME.round_resets.blind_tags.Big = get_next_tag_key('all_in_jest_guarrented_gold_tag')
end
for k, v in pairs(G.GAME.round_resets.blind_tags) do
    G.GAME.all_in_jest.blind_tags[k] = G.GAME.all_in_jest.blind_tags[k] or {}
    local temp_index = 0
    for i = 1, G.GAME.all_in_jest.blind_tags.amt do
        if i == 1 then -- Leftmost tag matches vanilla skip tag
            G.GAME.all_in_jest.blind_tags[k][i] = v
        else
            G.GAME.all_in_jest.blind_tags[k][i] = get_next_tag_key()
            while G.GAME.all_in_jest.blind_tags[k][i] == v do
                temp_index = temp_index + 1
                G.GAME.all_in_jest.blind_tags[k][i] = get_next_tag_key('_resample_'..temp_index)
            end
        end
    end
    pseudoshuffle(G.GAME.all_in_jest.blind_tags[k], pseudoseed('aij_branching')) -- So leftmost tag isn't always the "vanilla" one (or the forced gold one)
end
'''
match_indent = true

#--------------------------------------#
    # END OF PATCHES FOR NEW DECKS #
#--------------------------------------#

# Adds a new context that occurs slightly before after, used for effects that occur between the end of hand scoring and the score being tallied
# G.FUNCS.evaluate_play()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
G.E_MANAGER:add_event(Event({
    trigger = 'after',delay = 0.4,
    func = (function()  update_hand_text({delay = 0, immediate = true}, {mult = 0, chips = 0, chip_total = math.floor( SMODS.calculate_round_score() ), level = '', handname = ''});play_sound('button', 0.9, 0.6);return true end)
}))
'''
position = "before"
payload = '''
SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, all_in_jest = {before_after = true}, total_chips = math.floor(SMODS.calculate_round_score())})
'''
match_indent = true

# # Currently unused patch, used to be used for the brilliance
# # G.FUNCS.evaluate_play()
# [[patches]] 
# [patches.pattern]
# target = "functions/state_events.lua"
# pattern = '''
# G.E_MANAGER:add_event(Event({
#     trigger = 'after',delay = 0.4,
#     func = (function()  update_hand_text({delay = 0, immediate = true}, {mult = 0, chips = 0, chip_total = math.floor( SMODS.calculate_round_score() ), level = '', handname = ''});play_sound('button', 0.9, 0.6);return true end)
# }))
# '''
# position = "before"
# payload = '''
# if G.GAME.all_in_jest.reset_score.chips then
#     SMODS.Scoring_Parameters.chips:modify(-hand_chips)
#     G.GAME.all_in_jest.reset_score.chips = false
# end
# if G.GAME.all_in_jest.reset_score.mult then
#     SMODS.Scoring_Parameters.mult:modify(-mult)
#     G.GAME.all_in_jest.reset_score.mult = false
# end
# if G.GAME.all_in_jest.reset_score.chip_total then
#     SMODS.Scoring_Parameters.chips:modify(-hand_chips)
#     SMODS.Scoring_Parameters.mult:modify(-mult)
#     G.GAME.all_in_jest.reset_score.chip_total = false
# end
# '''
# match_indent = true

# Advanced hand information (1/3)
# Adds info about played hand to advanced hand info
# G.FUNCS.evaluate_play()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
G.E_MANAGER:add_event(Event({
    trigger = 'after',delay = 0.4,
    func = (function()  update_hand_text({delay = 0, immediate = true}, {mult = 0, chips = 0, chip_total = math.floor( SMODS.calculate_round_score() ), level = '', handname = ''});play_sound('button', 0.9, 0.6);return true end)
}))
'''
position = "before"
payload = '''
-- Using :save() to allow this info to be saved and reloaded
local blind = G.GAME.blind:save()
local full_hand_saved = {}
for k, v in pairs(G.play.cards) do
    full_hand_saved[k] = v:save()
end
local scoring_hand_saved = {}
for k, v in pairs(scoring_hand) do
    scoring_hand_saved[k] = v:save()
end
local poker_hands_saved = {}
for hand, _ in pairs(poker_hands) do
    poker_hands_saved[hand] = {}
    for i, _ in ipairs(poker_hands[hand]) do
        poker_hands_saved[hand][i] = {}
        for j, v in ipairs(poker_hands[hand][i]) do
            poker_hands_saved[hand][i][j] = v:save()
        end
    end
end

local hand_amt_thing = #G.GAME.all_in_jest.advanced_hand_usage_run + 1
G.GAME.all_in_jest.advanced_hand_usage_run[hand_amt_thing] = {}
G.GAME.all_in_jest.advanced_hand_usage_run[hand_amt_thing].mult = mult
G.GAME.all_in_jest.advanced_hand_usage_run[hand_amt_thing].chips = hand_chips
G.GAME.all_in_jest.advanced_hand_usage_run[hand_amt_thing].total_chips = math.floor(SMODS.calculate_round_score())
G.GAME.all_in_jest.advanced_hand_usage_run[hand_amt_thing].full_hand = full_hand_saved
G.GAME.all_in_jest.advanced_hand_usage_run[hand_amt_thing].scoring_hand = scoring_hand_saved  
G.GAME.all_in_jest.advanced_hand_usage_run[hand_amt_thing].scoring_name = text 
G.GAME.all_in_jest.advanced_hand_usage_run[hand_amt_thing].blind = blind
G.GAME.all_in_jest.advanced_hand_usage_run[hand_amt_thing].poker_hands = poker_hands_saved
local hand_amt_thing = #G.GAME.all_in_jest.advanced_hand_usage_ante + 1
G.GAME.all_in_jest.advanced_hand_usage_ante[hand_amt_thing] = {}
G.GAME.all_in_jest.advanced_hand_usage_ante[hand_amt_thing].mult = mult
G.GAME.all_in_jest.advanced_hand_usage_ante[hand_amt_thing].chips = hand_chips
G.GAME.all_in_jest.advanced_hand_usage_ante[hand_amt_thing].total_chips = math.floor(SMODS.calculate_round_score())
G.GAME.all_in_jest.advanced_hand_usage_ante[hand_amt_thing].full_hand = full_hand_saved
G.GAME.all_in_jest.advanced_hand_usage_ante[hand_amt_thing].scoring_hand = scoring_hand_saved  
G.GAME.all_in_jest.advanced_hand_usage_ante[hand_amt_thing].scoring_name = text
G.GAME.all_in_jest.advanced_hand_usage_ante[hand_amt_thing].blind = blind
G.GAME.all_in_jest.advanced_hand_usage_ante[hand_amt_thing].poker_hands = poker_hands_saved
local hand_amt_thing = #G.GAME.all_in_jest.advanced_hand_usage_blind + 1
G.GAME.all_in_jest.advanced_hand_usage_blind[hand_amt_thing] = {}
G.GAME.all_in_jest.advanced_hand_usage_blind[hand_amt_thing].mult = mult
G.GAME.all_in_jest.advanced_hand_usage_blind[hand_amt_thing].chips = hand_chips
G.GAME.all_in_jest.advanced_hand_usage_blind[hand_amt_thing].total_chips = math.floor(SMODS.calculate_round_score())
G.GAME.all_in_jest.advanced_hand_usage_blind[hand_amt_thing].full_hand = full_hand_saved
G.GAME.all_in_jest.advanced_hand_usage_blind[hand_amt_thing].scoring_hand = scoring_hand_saved 
G.GAME.all_in_jest.advanced_hand_usage_blind[hand_amt_thing].scoring_name = text 
G.GAME.all_in_jest.advanced_hand_usage_blind[hand_amt_thing].blind = blind
G.GAME.all_in_jest.advanced_hand_usage_blind[hand_amt_thing].poker_hands = poker_hands_saved
'''
match_indent = true

# Advanced hand information (2/3)
# Clear per-round advanced stats
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
SMODS.calculate_context({setting_blind = true, blind = G.GAME.round_resets.blind*
'''
position = "before"
payload = '''
for k, v in pairs(G.GAME.all_in_jest.advanced_hand_usage_blind) do
    G.GAME.all_in_jest.advanced_hand_usage_blind[k] = nil
end
'''
match_indent = true

# Advanced hand information (3/3)
# Clear per-ante advanced stats
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
SMODS.calculate_context({end_of_round = true, game_over = game_over, beat_boss = G.GAME.blind.boss*
'''
position = "before"
payload = '''
if G.GAME.blind.boss then
    for k, v in pairs(G.GAME.all_in_jest.advanced_hand_usage_ante) do
        G.GAME.all_in_jest.advanced_hand_usage_ante[k] = nil
    end
end
'''
match_indent = true

# # Currently unused patch, used to be used for the brilliance
# [[patches]] 
# [patches.pattern]
# target = "functions/state_events.lua"
# pattern = '''
# G.E_MANAGER:add_event(Event({
#     trigger = 'ease',
#     blocking = false,
#     ref_table = G.GAME,
#     ref_value = 'chips',
#     ease_to = G.GAME.chips + math.floor( SMODS.calculate_round_score() ),
#     delay =  0.5,
#     func = (function(t) return math.floor(t) end)
# }))
# '''
# position = "after"
# payload = '''
# if G.GAME.all_in_jest.reset_score.blind_total then
#     G.E_MANAGER:add_event(Event({
#       trigger = 'ease',
#       blocking = false,
#       ref_table = G.GAME,
#       ref_value = 'chips',
#       ease_to = 0,
#       delay =  0.5,
#       func = (function(t) return math.floor(t) end)
#     }))
#     G.GAME.all_in_jest.reset_score.blind_total = false
# end
# '''
# match_indent = true


# Context for before the Shop is Rerolled
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "calculate_reroll_cost(final_free)"
position = "before"
payload = '''
SMODS.calculate_context({all_in_jest = {before_reroll_shop = true, cost = reroll_cost}})
'''
match_indent = true

# Scapino (1/3) (Booster pack rerolling)
# Removes all booster packs on reroll
# G.FUNCS.reroll_shop()
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "for i = #G.shop_jokers.cards,1, -1 do"
position = "before"
payload = '''
if next(SMODS.find_card("j_aij_scapino")) then
    for i = #G.shop_booster.cards,1, -1 do
        local c = G.shop_booster:remove_card(G.shop_booster.cards[i])
        c:remove()
        c = nil
    end
end
'''
match_indent = true

# Scapino (2/3) (Booster pack rerolling)
# Adds new booster packs on reroll
# G.FUNCS.reroll_shop()
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "for i = 1, G.GAME.shop.joker_max - #G.shop_jokers.cards do"
position = "before"
payload = '''
if next(SMODS.find_card("j_aij_scapino")) then
    for i = 1, ((G.GAME.modifiers.extra_boosters or 0) + 2) - #G.shop_booster.cards do
        local new_shop_card = create_card_for_shop(G.shop_booster)
        G.shop_booster:emplace(new_shop_card)
        new_shop_card:juice_up()
    end
end
'''
match_indent = true

# Scapino (3/3) (Booster pack rerolling)
# Define card to create for the shop_booster area
# create_card_for_shop()
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''
if area == G.shop_jokers and G.SETTINGS.tutorial_progress and G.SETTINGS.tutorial_progress.forced_shop and G.SETTINGS.tutorial_progress.forced_shop[#G.SETTINGS.tutorial_progress.forced_shop] then
        local t = G.SETTINGS.tutorial_progress.forced_shop
        local _center = G.P_CENTERS[t[#t]] or G.P_CENTERS.c_empress
        local card = Card(area.T.x + area.T.w/2, area.T.y, G.CARD_W, G.CARD_H, G.P_CARDS.empty, _center, {bypass_discovery_center = true, bypass_discovery_ui = true})
        t[#t] = nil
        if not t[1] then G.SETTINGS.tutorial_progress.forced_shop = nil end
        
        create_shop_card_ui(card)
        return card
'''
position = 'after'
payload = '''
elseif area == G.shop_booster then
    local card = Card(G.shop_booster.T.x + G.shop_booster.T.w/2,
    G.shop_booster.T.y, G.CARD_W*1.27, G.CARD_H*1.27, G.P_CARDS.empty, G.P_CENTERS[get_pack('shop_pack').key], {bypass_discovery_center = true, bypass_discovery_ui = true})
    create_shop_card_ui(card, 'Booster', G.shop_booster)
    return card
'''
match_indent = true

# Activated Ability Button UI (1/4)
# Clear use button before creating it
# G.UIDEF.use_and_sell_buttons()
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''
local use = nil
'''
position = 'after'
payload = '''
local aij_activate_ability = nil
'''
match_indent = true

# Activated Ability Button UI (2/4)
# Defines the use button used for activated jokers
# G.UIDEF.use_and_sell_buttons()
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''
if card.area and card.area.config.type == 'joker' then
'''
position = 'after'
payload = '''
if card.config.center.all_in_jest and card.config.center.all_in_jest.use_ability then 
    local use_button = {n=G.UIT.T, config={text = localize('b_use'),colour = G.C.UI.TEXT_LIGHT, scale = card.config.center.all_in_jest.ability_cost and card.aij_ability_cost_label and 0.4 or 0.55, shadow = true}}
    aij_activate_ability = {n=G.UIT.C, config={align = "cr"}, nodes={
        {n=G.UIT.C, config={ref_table = card, align = "cr",maxw = 1.25, padding = 0.1, r=0.08, minw = 1.25, minh = (card.area and card.area.config.type == 'joker') and 0 or 1, hover = true, shadow = true, colour = G.C.UI.BACKGROUND_INACTIVE, button = 'All_in_Jest_use_active_ability_button', func = 'All_in_Jest_can_use_active_ability_button'}, nodes={
            {n=G.UIT.B, config = {w=0.1,h=0.6}},
                card.config.center.all_in_jest.ability_cost and card.aij_ability_cost_label and {n=G.UIT.C, config={align = "tm"}, nodes={
                    {n=G.UIT.R, config={align = "cm", maxw = 1.25}, nodes={
                        use_button,
                    }},
                    {n=G.UIT.R, config={align = "cm"}, nodes={
                        {n=G.UIT.T, config={text = '-'..localize('$'),colour = G.C.WHITE, scale = 0.4, shadow = true}},
                        {n=G.UIT.T, config={ref_table = card, ref_value = 'aij_ability_cost_label',colour = G.C.WHITE, scale = 0.55, shadow = true}}
                    }
                } 
            }} or use_button
        }}
    }}
end
'''
match_indent = true

# Activated Ability Button UI (3/4)
# Place the use button for activated jokers
# G.UIDEF.use_and_sell_buttons()
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''
{n=G.UIT.R, config={align = 'cl'}, nodes={
    sell
}},
'''
position = 'after'
payload = '''
{n=G.UIT.R, config={align = 'cr'}, nodes={
    aij_activate_ability
}},
'''
match_indent = true

# Activated Ability Button UI (4/4)
# Attaches the "Use" button to activated ability patches
# Used for controller
# G.UIDEF.card_focus_ui()
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''
base_attach.children.sell = G.UIDEF.card_focus_button{
'''
position = 'before'
payload = '''
if card.config.center.all_in_jest and card.config.center.all_in_jest.use_ability then 
    base_attach.children.aij_activate_ability = G.UIDEF.card_focus_button{
        card = card, parent = base_attach, type = 'use',
        func = 'All_in_Jest_can_use_active_ability_button', button = 'All_in_Jest_use_active_ability_button', card_width = card_width
    }
end
'''
match_indent = true

# Prevent jokers that can only appear in shop or booster packs from appearing elsewhere
# create_card()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''if forced_key and not G.GAME.banned_keys[forced_key] then'''
position = "before"
match_indent = true
payload = '''
-- All in Jest patch
if _type == 'Joker' then
    local _pool, _pool_key = get_current_pool(_type, _rarity, legendary, key_append)
    for k, v in pairs(_pool) do
        if G.P_CENTERS[v] and G.P_CENTERS[v].all_in_jest then
            local appear = false
            if (G.P_CENTERS[v].all_in_jest.only_shop_pool and area == G.shop_jokers) then
                appear = true
            elseif (G.P_CENTERS[v].all_in_jest.only_booster_pool and area == G.pack_cards) then
                appear = true
            end
            if G.P_CENTERS[v].all_in_jest.only_shop_pool or G.P_CENTERS[v].all_in_jest.only_booster_pool then
                if appear then
                    G.P_CENTERS[v].in_pool = function(self, args)
    		                return true
                    end
                else
                    G.P_CENTERS[v].in_pool = function(self, args)
    		                return false
                    end
                end
            end
        end
    end
end
-- End of All in Jest patch
'''

# Dark Magician Combines pools
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''local _pool, _starting_pool, _pool_key, _pool_size = G.ARGS.TEMP_POOL, nil, '', 0'''
position = "after"
match_indent = true
payload = '''
if _append == 'dark_magician_get_other_pools' and next(SMODS.find_card("j_aij_dark_magician")) then
    _pool = {}
end
if _append ~= 'dark_magician_get_other_pools' and next(SMODS.find_card("j_aij_dark_magician")) then
    if _type == 'Tarot'  then
        local add_pool, discard_key = get_current_pool('Spectral', _rarity, _legendary, 'dark_magician_get_other_pools')
        local add_pool2, discard_key2 = get_current_pool('Planet', _rarity, _legendary, 'dark_magician_get_other_pools')
        if add_pool ~= _pool then
            for i = 1, #add_pool do
                _pool[#_pool + 1] = add_pool[i]
            end
        end
        if add_pool2 ~= _pool then
            for i = 1, #add_pool2 do
                _pool[#_pool + 1] = add_pool2[i]
            end
        end
    elseif _type == 'Planet' then
        local add_pool, discard_key = get_current_pool('Spectral', _rarity, _legendary, 'dark_magician_get_other_pools')
        local add_pool2, discard_key2 = get_current_pool('Tarot', _rarity, _legendary, 'dark_magician_get_other_pools')
        if add_pool ~= _pool then
            for i = 1, #add_pool do
                _pool[#_pool + 1] = add_pool[i]
            end
        end
        if add_pool2 ~= _pool then
            for i = 1, #add_pool2 do
                _pool[#_pool + 1] = add_pool2[i]
            end
        end
    elseif _type == 'Tarot_Planet' then
        local add_pool, discard_key = get_current_pool('Spectral', _rarity, _legendary, 'dark_magician_get_other_pools')
        if add_pool ~= _pool then
            for i = 1, #add_pool do
                _pool[#_pool + 1] = add_pool[i]
            end
        end
    elseif _type == 'Spectral' then
        local add_pool, discard_key = get_current_pool('Tarot', _rarity, _legendary, 'dark_magician_get_other_pools')
        local add_pool2, discard_key2 = get_current_pool('Planet', _rarity, _legendary, 'dark_magician_get_other_pools')
        if add_pool ~= _pool then
            for i = 1, #add_pool do
                _pool[#_pool + 1] = add_pool[i]
            end
        end
        if add_pool2 ~= _pool then
            for i = 1, #add_pool2 do
                _pool[#_pool + 1] = add_pool2[i]
            end
        end
    end
end
'''

# Dark Magician the fool compact
[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = "if card.config.center.set == 'Tarot' or card.config.center.set == 'Planet' then"
position = "before"
match_indent = true
payload = '''
if card.config.center.set == 'Spectral' and next(SMODS.find_card("j_aij_dark_magician")) then 
    G.E_MANAGER:add_event(Event({
        trigger = 'immediate',
        func = function()
        G.E_MANAGER:add_event(Event({
            trigger = 'immediate',
            func = function()
            G.GAME.last_tarot_planet = card.config.center_key
                return true
            end
        }))
            return true
        end
    }))
end
'''

# # Corndog code
# [[patches]]
# [patches.pattern]
# target = "functions/misc_functions.lua"
# pattern = 'if results["Three of a Kind"][1] then'
# position = "before"
# match_indent = true
# payload = '''

# '''

# Have tags in the round eval screen use the correct atlas
# (How does SMODs not change this???)
# add_round_eval_row()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''local blind_sprite = SMODS.create_sprite(0, 0, 0.7,0.7, 'tags', copy_table(config.pos))'''
position = "after"
match_indent = true
payload = '''
if config.tag.config.aij then
    blind_sprite = SMODS.create_sprite(0, 0, 0.7,0.7, 'aij_tag_atlas', copy_table(config.pos))
end
'''

# Track hands and discards remaining on a whole-run and per-ante basis
# Ante stats shouldn't be set here for boss blind
# Only used for a few effects as of v0.6
# G.FUNCS.evaluate_round()
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "add_round_eval_row({dollars = G.GAME.current_round.hands_left*(G.GAME.modifiers.money_per_hand or 1), disp = G.GAME.current_round.hands_left, bonus = true, name='hands', pitch = pitch})"
position = "before"
match_indent = true
payload = '''
G.GAME.all_in_jest.unused_hands.run = G.GAME.all_in_jest.unused_hands.run + G.GAME.current_round.hands_left
G.GAME.all_in_jest.unused_hands.ante = G.GAME.all_in_jest.unused_hands.ante + G.GAME.current_round.hands_left
G.GAME.all_in_jest.unused_discards.ante = G.GAME.all_in_jest.unused_discards.ante + G.GAME.current_round.discards_left
'''

############################
    # GOLD TAG PATCHES #
############################

# Gold Tags (1/9)
# Exclude either gold tags or non-gold tags from collection depending if on gold tag screen or not
# create_UIBox_your_collection_tags_content()
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/overrides.lua"]'
pattern = 'for k, v in ipairs(tag_tab) do'
position = "before"
match_indent = true
payload = '''
for i = #tag_tab, 1, -1 do
    local v = tag_tab[i]
    if v.config.aij and v.config.aij.upgrade and not G.GAME.jest_upgrade_tab then
        table.remove(tag_tab, i)
    elseif G.GAME.jest_upgrade_tab then
        if not (v.config.aij and v.config.aij.upgrade) then
            table.remove(tag_tab, i)
        end
    end
end
'''

# Gold Tags (2/9)
# Add a button to access gold tags collection
# create_UIBox_your_collection_tags_content()
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/overrides.lua"]'
pattern = '''
create_option_cycle({
	options = page_options,
	w = 4.5,
	cycle_shoulders = true,
	opt_callback = 'your_collection_tags_page',
	focus_args = { snap_to = true, nav = 'wide' },
	current_option = page,
	colour = G.ACTIVE_MOD_UI and (G.ACTIVE_MOD_UI.ui_config or {}).collection_option_cycle_colour or G.C.RED,
	no_pips = true
})'''
position = "after"
match_indent = true
payload = ''',
{n=G.UIT.R, config={align = "cm", r = 0.1, w = 0.2, minh = 0.9, hover = true, colour = G.C.GOLD, button = "jest_gold_tags", shadow = true, focus_args = {nav = 'wide', snap_to = true}}, nodes={
    {n=G.UIT.R, config={align = "cm", padding = 0, no_fill = true, maxw = 4.8}, nodes={
        {n=G.UIT.T, config={text = localize('aij_upgraded_tags'), scale = 0.5, colour = G.C.UI.TEXT_LIGHT}}
    }}
}},
'''

# Gold tags (3/9)
# Set pool to return pool of golden tags when type "Jest Golden Tag" is given
# get_current_pool()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''local _pool, _starting_pool, _pool_key, _pool_size = G.ARGS.TEMP_POOL, nil, '', 0'''
position = "after"
match_indent = true
payload = '''
local jest_golden = false
if _type == 'Jest Golden Tag' then
    jest_golden = true
    _type = 'Tag'
end
''' 

# Gold tags (4/9)
# Include or exclude gold tags from pool depending on if regular or golden tags were requested
# get_current_pool()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
if (not v.requires or (G.P_CENTERS[v.requires] and G.P_CENTERS[v.requires].discovered)) and 
(not v.min_ante or v.min_ante <= G.GAME.round_resets.ante) then
    add = true
end
'''
position = "after"
match_indent = true
payload = '''
if v.config.aij and v.config.aij.upgrade then
    if not jest_golden then
        add = nil
    end
else
    if jest_golden then
        add = nil
    end
end
'''

# Gold tags (5/9)
# Generate a pool of gold tags separate from the other tags
# get_next_tag_key()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "local _pool, _pool_key = get_current_pool('Tag', nil, nil, append)"
position = "before"
match_indent = true
payload = '''
local _temp_gold_pool, _gold_pool_key = get_current_pool('Jest Golden Tag', nil, nil, append and append..'_gold' or '_gold')
_gold_pool = {}
for i = 1, #_temp_gold_pool do
    _gold_pool[i] = _temp_gold_pool[i]
end
'''

# Gold tags (6/9)
# Determines whether or not to generate a gold tag
# get_next_tag_key()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "local _tag = pseudorandom_element(_pool, pseudoseed(_pool_key))"
position = "after"
match_indent = true
payload = '''
if #_gold_pool == #_pool and #_gold_pool ~= 1 then
    for i = 1, #_pool do
        if _gold_pool[i] ~= 'UNAVAILABLE' and _pool[i] == 'UNAVAILABLE' then
            _pool[i] = _gold_pool[i]
        end
    end
end
if #_gold_pool > 0 and _gold_pool[1] ~= 'tag_handy' then
    if Tag(_tag).config.aij and Tag(_tag).config.aij.upgrade then -- True if it is a gold tag
        local gt = 1
        local gold = false
        while Tag(_tag).config.aij and Tag(_tag).config.aij.upgrade and not gold do
            if not (pseudorandom('gold_tag_rate') < (1 * G.GAME.all_in_jest.gold_tag_rate) / 30) then
                gt = gt + 1
                _tag = pseudorandom_element(_pool, pseudoseed(_pool_key..'_resample_gold'..gt))
            else
                gold = true
            end
        end
    else
        if pseudorandom('gold_tag_rate') < (1 * G.GAME.all_in_jest.gold_tag_rate) / 30 then
            _tag = pseudorandom_element(_gold_pool, pseudoseed(_gold_pool_key..'_resample_gold'))
        end
    end
    if append and append == 'all_in_jest_guarrented_gold_tag' then
        _tag = pseudorandom_element(_gold_pool, pseudoseed(_gold_pool_key..'_resample_gold'))
    end
end
'''

# Gold tags (7/9)
# Determines whether or not to generate a gold tag again, if first tag happened to be UNAVAILABLE
# get_next_tag_key()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "_tag = pseudorandom_element(_pool, pseudoseed(_pool_key..'_resample'..it))"
position = "after"
match_indent = true
payload = '''
if #_gold_pool > 0 and _gold_pool[1] ~= 'tag_handy' then
    if Tag(_tag).config.aij and Tag(_tag).config.aij.upgrade then
        local gt = 1
        local gold = false
        while Tag(_tag).config.aij and Tag(_tag).config.aij.upgrade and not gold do
            if not (pseudorandom('gold_tag_rate') < (1 * G.GAME.all_in_jest.gold_tag_rate) / 30) then
                gt = gt + 1
                _tag = pseudorandom_element(_pool, pseudoseed(_pool_key..'_resample_gold'..gt))
            else
                gold = true
            end
        end
    else
        if pseudorandom('gold_tag_rate') < (1 * G.GAME.all_in_jest.gold_tag_rate) / 30 then
            _tag = pseudorandom_element(_gold_pool, pseudoseed(_gold_pool_key..'_resample_gold'))
        end
    end
    if append and append == 'all_in_jest_guarrented_gold_tag' then
        _tag = pseudorandom_element(_gold_pool, pseudoseed(_gold_pool_key..'_resample_gold'))
    end
end
'''

# Gold Tags (8/9)
# Set undiscovered gold tag sprite
# Tag:generate_UI()
[[patches]]
[patches.pattern]
target = "tag.lua"
pattern = 'local tag_sprite = *'
position = "after"
match_indent = true
payload = '''
if self.config.aij and self.config.aij.upgrade then
    tag_sprite = SMODS.create_sprite(0,0,_size*1,_size*1,SMODS.get_atlas((not self.hide_ability) and G.P_TAGS[self.key].atlas or "aij_tag_atlas"), (self.hide_ability) and { x = 5, y = 4 } or self.pos)
end
''' 

# Gold Tags (9/9)
# Double tags cannot copy gold tags
# Tag:apply_to_run()
[[patches]]
[patches.pattern]
target = "tag.lua"
pattern = "if self.name == 'Double Tag' and _context.tag.key ~= 'tag_double' then"
position = "after"
match_indent = true
payload = '''
    if _context.tag.config.aij and _context.tag.config.aij.upgrade then return end
'''

#---------------------------------#
    # END OF GOLD TAG PATCHES #
#---------------------------------#

# Set collection page to page 1 if entering/exiting a gold tags page
# Game:update()
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "for k, v in pairs(self.ANIMATIONS) do"
position = "before"
match_indent = true
payload = '''
if G.GAME.previous_jest_upgrade_tab ~= G.GAME.jest_upgrade_tab then
    G.FUNCS.your_collection_tags_page({cycle_config = {current_option = 1}})
    G.GAME.previous_jest_upgrade_tab = G.GAME.jest_upgrade_tab
end
'''
# Make cards and boosters free if set by jest_shop_perma_free
# Used by the Frugal tag (golden coupon tag)
# Game:update()
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "for k, v in pairs(self.ANIMATIONS) do"
position = "before"
match_indent = true
payload = '''
if (G.shop and not G.GAME.shop_free and G.GAME.jest_shop_perma_free) then
    if G.shop_jokers and G.shop_booster then 
        for k, v in pairs(G.shop_jokers.cards) do
            v.ability.couponed = true
            v:set_cost()
        end
        for k, v in pairs(G.shop_booster.cards) do
            v.ability.couponed = true
            v:set_cost()
        end
    end
end
'''

###########################
    # NEW BLIND STUFF #
###########################

# AiJ Blind Functionality (1/4)
# Trigger any "update" methods of blinds
# Currently only used by The Oak (debuffs rightmost joker)
# Game:update()
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "for k, v in pairs(self.ANIMATIONS) do"
position = "before"
match_indent = true
payload = '''
-- updates for blinds & abilities for blinds
if G.GAME.blind and G.GAME.blind.config.blind.update and type(G.GAME.blind.config.blind.update) == 'function' then
    G.GAME.blind.config.blind.update(G.GAME.blind, G.GAME.blind, dt)
end
'''

# AiJ Blind Functionality (2/4)
# Transfer a blind's config over to its ability
# Will trigger upon selecting a boss blind
# Game:update()
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "for k, v in pairs(self.ANIMATIONS) do"
position = "before"
match_indent = true
payload = '''
if G.GAME.blind and G.GAME.blind.config.blind.config and type(G.GAME.blind.config.blind.config) == 'table' then
    if G.GAME.blind.in_blind then
        if not G.GAME.blind.ability then
            G.GAME.blind.ability = G.GAME.blind.ability or {}
            for k, v in pairs(G.GAME.blind.config.blind.config) do
                if type(v) == 'table' then
                    G.GAME.blind.ability[k] = copy_table(v)
                else
                    G.GAME.blind.ability[k] = v
                end
            end
        end
    else
        G.GAME.blind.ability = nil
    end
end
'''

# AiJ Blind Functionality (3/4)
# Save ability table of bosses
# Blind:save()
[[patches]]
[patches.pattern]
target = '''blind.lua'''
pattern = '''
function Blind:save()
    local blindTable = {
'''
position = "after"
match_indent = true
payload = '''
    ability = self.ability,
'''

# AiJ Blind Functionality (4/4)
# Load ability table of bosses
# Blind:load()
[[patches]]
[patches.pattern]
target = '''blind.lua'''
pattern = '''
function Blind:load(blindTable)
'''
position = "after"
match_indent = true
payload = '''
    self.ability = blindTable.ability
'''

# AiJ Blind Functionality (5/5)
# Allows blinds to display a dynamic blind amount on blind select screen without changing the chip value directly
# Hooked into via new aij_blind_amount_display() method in blind objects
# create_UIBox_blind_choice()
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = "local blind_amt = *"
position = 'after'
match_indent = true
payload = '''

if All_in_Jest.aij_alias_type(blind_choice.config.aij_blind_amount_display) == 'function' then
    local blind_mult = blind_choice.config.mult
    if next(SMODS.find_card("j_aij_fall_of_count_chaligny")) then
        blind_mult = 1
    end
    ret = blind_choice.config:aij_blind_amount_display(blind_choice.config, get_blind_amount(G.GAME.round_resets.blind_ante), blind_mult)
    if All_in_Jest.aij_alias_type(ret) == "number" then
        blind_amt = ret * G.GAME.starting_params.ante_scaling
    end
elseif next(SMODS.find_card("j_aij_fall_of_count_chaligny")) then
    blind_amt = get_blind_amount(G.GAME.round_resets.blind_ante)*1*G.GAME.starting_params.ante_scaling
end
'''

# Pit Blinds (1/1)
# Patch to force pit blind on ante 4/5 or during the all pit blinds challenge
# get_new_boss()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''for k, v in pairs(G.GAME.bosses_used) do'''
position = "before"
match_indent = true
payload = '''
-- AIJ Patch
if All_in_Jest.force_pit_blind() then
    for k, v in pairs(eligible_bosses) do
        if eligible_bosses[k] and not (G.P_BLINDS[k] and G.P_BLINDS[k].boss and G.P_BLINDS[k].boss.all_in_jest and G.P_BLINDS[k].boss.all_in_jest.pit) then
            eligible_bosses[k] = nil
        end
    end
end
-- end AIJ patch
'''

# The Clay blind (1/2)
# Make blind display randomly change with The Clay blind
# By coincidence this also works when UnBlind is installed, just gotta use the blind_state_text_colour variable to check if its in UnBlind's code or not
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = "{n=G.UIT.T, config={text = number_format(blind_amt)*"
position = 'before'
match_indent = true
payload = '''(blind_choice.config.name == "bl_aij_the_clay" and not aij_has_blind_drawn and {n=G.UIT.O, config={object = DynaText({string = getRandomClayBlindReqs(blind_amt), colours = {disabled and G.C.UI.TEXT_INACTIVE or blind_state_text_colour or G.C.RED},pop_in_rate = 9999999, silent = true, random_element = true, pop_delay = 0.5, scale = score_number_scale(blind_state_text_colour and 0.47 or 0.9, blind_amt), shadow = not disabled, min_cycle_time = 0})}}) or'''

# The Clay blind (2/2)
# create_UIBox_blind_popup
# Adds custom blind description for The Clay in the collection
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = "{n=G.UIT.T, config={text = blind.mult..localize('k_x_base'), scale = 0.4, colour = G.C.RED}},"
position = "before"
match_indent = true
payload = '''blind.key == "bl_aij_the_clay" and {n=G.UIT.T, config={text = "2~5"..localize('k_x_base'), scale = 0.4, colour = G.C.RED}} or 
              blind.aij_variable_req and false and {n=G.UIT.T, config={text = blind.mult.."+?"..localize('k_x_base'), scale = 0.4, colour = G.C.RED}} or '''

# The Journey Blind (1/1)
# Set The Journey to have a special background when activated
# ease_background_colour_blind()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "elseif blindname == 'Small Blind' or blindname == 'Big Blind' or blindname == '' then"
position = "before"
match_indent = true
payload = '''elseif blindname == 'bl_aij_the_journey' and G.GAME.current_round.aij_the_journey_blind and G.GAME.current_round.aij_the_journey_blind.triggered then
    boss_col = darken(G.P_BLINDS["bl_aij_the_journey"].boss_colour, 0.2)
    G.ARGS.spin.real = -1
    ease_background_colour{new_colour = lighten(mix_colours(boss_col, G.C.BLACK, 0.3), 0.1), special_colour = boss_col, contrast = 5}

    if G.aij_the_journey_stars == nil then
        G.aij_the_journey_stars = Particles(1, 1, 0,0, {
            timer = 0.07,
            scale = 0.1,
            initialize = true,
            lifespan = 15,
            speed = 0.1,
            padding = -4,
            attach = G.ROOM_ATTACH,
            colours = {G.C.WHITE, boss_col, lighten(boss_col, 0.2)},
            fill = true
        })
    end
'''

#--------------------------------#
    # END OF NEW BLIND STUFF #
#--------------------------------#

# Do not increase reroll cost if shop_galloping_dominoed is set
# Used by gold tag of the same name (gold d6 tag)
# calculate_reroll_cost()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if not skip_increment then G.GAME.current_round.reroll_cost_increase = G.GAME.current_round.reroll_cost_increase + 1 end"
position = "before"
match_indent = true
payload = '''
if G.GAME.shop_galloping_dominoed then skip_increment = true; G.GAME.round_resets.temp_reroll_cost = G.GAME.shop_galloping_dominoed end
'''

# Give consumables editions if Bartender is owned
# create_card()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if card.ability.consumeable and not skip_materialize then card:start_materialize() end"
position = "after"
match_indent = true
payload = '''
if card.ability.consumeable and next(SMODS.find_card("j_aij_bartender")) then
    if not SMODS.bypass_create_card_edition and not card.edition then
        local edition = poll_edition('aura', nil, true)
        if edition then
            card:set_edition(edition)
        end
    end
end
'''

# Make Infuriating Note negative in the shop and packs if Infuriating Note is owned
# create_card()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if card.ability.consumeable and not skip_materialize then card:start_materialize() end"
position = "after"
match_indent = true
payload = '''
if card.config.center and card.config.center_key == 'j_aij_infuriating_note' and next(SMODS.find_card("j_aij_infuriating_note")) then
    if (area == G.shop_jokers or area == G.pack_cards) then
        card:set_edition({ negative = true })
    end
end
'''

# Make simple simon the default joker to appear if little boy blue is owned
# get_current_pool()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''elseif _type == 'Joker' then _pool[#_pool + 1] = "j_joker"'''
position = "before"
match_indent = true
payload = '''
elseif _type == 'Joker' and next(SMODS.find_card("j_aij_little_boy_blue")) then _pool[#_pool + 1] = "j_aij_simple_simon"
'''


# Remove the additional cost of the edition under certain conditions
# Card:set_cost()
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.extra_cost = self.extra_cost + v.extra_cost"
position = "after"
match_indent = true
payload = '''
local has_chef = next(SMODS.find_card("j_aij_chef"))
if has_chef and self.ability.perishable then self.extra_cost = 0 end
local has_note = next(SMODS.find_card("j_aij_infuriating_note"))
if has_note and self.config.center_key == 'j_aij_infuriating_note' then self.extra_cost = 0 end
'''

# Make free reroll button appear when granted
# (As of v0.6 its just for stultor)
# create_UIBox_blind_select()
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '(G.GAME.used_vouchers["v_retcon"] or G.GAME.used_vouchers["v_directors_cut"]) and'
position = "before"
match_indent = true
payload = '''
(G.GAME.jest_free_stultor_rerolls > 0) and
UIBox_button({label = {localize('b_reroll_boss'), localize('$')..'0'}, button = "jest_free_reroll_boss", func = 'jest_free_reroll_boss_button'}) or
'''

# Grant lucky cards additional +mult from other effects (rather than only giving +20 mult on a trigger)
# Card:get_chip_mult()
[[patches]] 
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.effect == "Lucky Card" then
        if SMODS.pseudorandom_probability(self, 'lucky_mult', 1, 5) then
            self.lucky_trigger = true
            ret = ret + self.ability.mult
        end
    else
'''
position = "at"
payload = '''
local is_chip_mult = self.ability._saved_chip_values ~= nil

if self.ability.effect == "Lucky Card" then
    local base_mult = 0
    if is_chip_mult then
        base_mult = (self.ability._saved_chip_values.nominal or 0) +
                    (self.ability._saved_chip_values.bonus or 0) +
                    (self.ability._saved_chip_values.perma_bonus or 0)
    end
    
    local ret = base_mult + ((not self.ability.extra_enhancement and self.ability.perma_mult) or 0)

    if SMODS.pseudorandom_probability(self, 'lucky_mult', 1, 5) then
        self.lucky_trigger = true
        ret = ret + self.ability.mult
    end
    return ret
else
'''
match_indent = true

# Add context for when an edition is triggered
# (As of v0.6 is just for Chromasist)
# eval_card()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "local edition = card:calculate_edition(context)"
position = "after"
match_indent = true
payload = '''
if edition then
    local flags = SMODS.calculate_context({all_in_jest = {calculating_edition = true, other_card = card, edition = card.edition, area = card.area }})
    ret.extra = flags
end
'''

# Adds tooltip for suit patches
# generate_card_ui()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if _c.set == 'Other' then"
position = "before"
match_indent = true
payload = '''
if card and card.ability and card.ability.patches then
    for k, v in pairs(card.ability.patches) do
        if G.C.SUITS[k] then
            info_queue[#info_queue+1] = {key = 'aij_patches_suit', set = 'Other', vars = {localize(k, "suits_singular"), colours = {G.C.SUITS[k]}}}
        elseif G.SETTINGS.colour_palettes[k] == 'hc' then
            info_queue[#info_queue+1] = {key = 'aij_patches_suit', set = 'Other', vars = {localize(k, "suits_singular"), colours = {SMODS.Suits[k].hc_colour}}}
        else
            info_queue[#info_queue+1] = {key = 'aij_patches_suit', set = 'Other', vars = {localize(k, "suits_singular"), colours = {SMODS.Suits[k].lc_colour}}}
        end
    end
end
'''

# Adds tooltip for special "stickers"
# (Mark of the Spear)
# generate_card_ui()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if _c.set == 'Other' then"
position = "before"
match_indent = true
payload = '''
if (card and card.ability and card.ability.all_in_jest and card.ability.all_in_jest.perma_debuff) then 
    info_queue[#info_queue+1] = {key = 'aij_jest_mark_of_the_spear', set = 'Other'}
end
'''

# Add the tooltip that says negative does not get copied
# generate_card_ui()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "local t = {key = 'e_'..v, set = 'Edition', config = {}}"
position = "after"
match_indent = true
payload = '''
if not All_in_Jest.config.no_copy_neg and v == 'negative_playing_card' then
    t = {key = 'e_aij_negative_playing_card', set = 'Edition', config = {extra = G.P_CENTERS['e_negative'].config.card_limit}}
end
'''

# Define a custom badge to use for Chaotic Cards
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/game_object.lua"]'
pattern = "SMODS.Rarities = {}"
position = "before"
payload = '''
SMODS.jest_Badges = {}
SMODS.jest_Badge = SMODS.GameObject:extend {
    obj_table = SMODS.jest_Badges,
    obj_buffer = {},
    set = 'jest_Badge',
    required_params = {
        'key',
    },
    badge_colour = HEX 'FFFFFF',
    inject = function(self, center) 
        if center.set ~= self.key then SMODS.insert_pool(SMODS.jest_Badges[self.key], center) end
        if not center.pools then center.pools = {} end
        center.pools[self.key] = true
        G.C.jest_Badge[self.key] = self.badge_colour
    end,
    process_loc_text = function(self)
        SMODS.process_loc_text(G.localization.misc.labels, "k_"..self.key:lower(), self.loc_txt, 'name')
        SMODS.process_loc_text(G.localization.misc.dictionary, "k_"..self.key:lower(), self.loc_txt, 'name')
    end,
    get_badge = function(self, badge)
        return localize("k_"..badge:lower())
    end,
}

local game_init_game_object_ref = Game.init_game_object
function Game:init_game_object()
    local t = game_init_game_object_ref(self)
    for _, v in pairs(SMODS.jest_Badges) do
        local key = v.key:lower() .. '_mod'
        t[key] = t[key] or 1
    end
    return t
end
'''
match_indent = true 

# Inject custom badge
# Game:init_game_object
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/game_object.lua"]'
pattern = "for _, v in pairs(SMODS.Rarities) do"
position = "before"
payload = '''
for _, v in pairs(SMODS.jest_Badges) do
    self:inject(v)
end
'''
match_indent = true 

# Remove negative from copied cards
# copy_card
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if not strip_edition then"
position = "before"
match_indent = true
payload = '''
if other.edition and other.edition.negative and not All_in_Jest.config.no_copy_neg and not G.VIEWING_DECK and not other.ability.jest_copy_edition then 
    if other.ability.set == 'Enhanced' or other.ability.set == 'Default' then
        strip_edition = true
    end
end
other.ability.jest_copy_edition = false
'''

# Round dollars earned at the end of the round to the nearest whole number
# G.FUNCS.evaluate_round()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = "add_round_eval_row({name = 'bottom', dollars = dollars*"
position = "before"
payload = '''
dollars = math.floor(dollars + 0.5)
'''
match_indent = true

# Add context for before a consumable is used
# As of v0.6, just for Lost Carcosa (randomises planet values)
# Card:use_consumeable()
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "local used_tarot = copier or self"
position = "after" 
match_indent = true
payload = '''
SMODS.calculate_context({all_in_jest = {before_using_consumeable = true, consumeable = self, area = area }})
'''

# TODO: fix this
# This patch is weird, applies to too many places and creates dead code
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
if _type == 'Joker' then 
'''
position = "before"
match_indent = true
payload = '''
if G.GAME.jest_legendary_pool ~= nil and _type == 'Joker' then
    if G.GAME.jest_legendary_pool.in_shop then
        local legend_mod = 1 - G.GAME.jest_legendary_pool.rate
        legend_mod = (legend_mod * G.GAME.legendary_mod) - legend_mod
        legend_mod = G.GAME.jest_legendary_pool.rate - legend_mod
        local rary = _rarity or pseudorandom('rarity'..G.GAME.round_resets.ante..(_append or '')) 
        if type(rary) == "number" and (_rarity == nil or _rarity == 4 or _rarity == "Legendary") then
            rary = (rary > legend_mod and 4) or 1 
            if rary ~= 1 then
                _legendary = true
            end
        end
    end
end
'''

# Make legendary jokers in the shop show their description
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.config.center.unlocked == false and not self.bypass_lock then --For everyting that is locked
'''
position = "at"
match_indent = true
payload = '''
if self.config.center.unlocked == false and not self.bypass_lock and not self.bypass_discovery_ui then --For everyting that is locked
'''

# Warhol (1/2)
# Gold Seal
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = """elseif self.seal == 'Gold' and not self.ability.extra_enhancement then"""
position = "before"
match_indent = true
payload = '''
elseif next(SMODS.find_card("j_aij_warhol")) and self.seal and not self.ability.extra_enhancement then
    ret = ret +  3
'''

# Warhol (2/2)
# Red Seal
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = """if self.seal == 'Red' then"""
position = "at"
match_indent = true
payload = '''
if self.seal == 'Red' or (next(SMODS.find_card("j_aij_warhol")) and self.seal) then
'''

# The Grim Joker (Purple Seals) (1/3)
# Adds chance for negative tarots to be created by purple seals
# and forces card creation even if it "exceeds" the card limit
[[patches]]
[patches.regex]
target = "card.lua"
pattern = '''
(?<indent>[\t ]*)if self\.seal == 'Purple' and #G\.consumeables\.cards \+ G\.GAME\.consumeable_buffer < G\.consumeables\.config\.card_limit (?<post>.*)
'''
position = "at"
line_prepend = '$indent'
payload = '''
-- All in Jest patch
local aij_purple_seal_is_negative = false
if self.seal == 'Purple' or (next(SMODS.find_card("j_aij_warhol")) and self.seal) then
    local ret = SMODS.calculate_context({
        aij_grim_joker_bluepurple_seal = true
    })
    aij_purple_seal_is_negative = ret.aij_grim_joker_bluepurple_seal_negative_mod
end
-- End All in Jest patch
if (self.seal == 'Purple' or (next(SMODS.find_card("j_aij_warhol")) and self.seal)) and (aij_purple_seal_is_negative or (#G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit)) $post
'''
# The Grim Joker (Purple Seals) (2/3)
# Undo buffer change so that non-negative consumables aren't prevented from spawning
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.seal == 'Purple'*
    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1'''
position = "after"
match_indent = true
payload = '''
    -- All in Jest patch
    if aij_purple_seal_is_negative then
        G.GAME.consumeable_buffer = G.GAME.consumeable_buffer - 1
    end
    -- End All in Jest patch
'''
# The Grim Joker (Purple Seals) (3/3)
# Applies negative to card if set to be negative
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "local card = create_card('Tarot',G.consumeables, nil, nil, nil, nil, nil, '8ba')"
position = "after"
match_indent = true
payload = '''
-- All in Jest patch
if aij_purple_seal_is_negative then -- Will always be faled in 8-ball calc
    card:set_edition({negative = true}, true)
end
-- End All in Jest patch
'''
# The Grim Joker (Blue Seals) (1/3)
# Adds chance for negative planets to be created by blue seals
# and forces card creation even if it "exceeds" the card limit
[[patches]]
[patches.regex]
target = "card.lua"
pattern = '''
(?<indent>[\t ]*)if self\.seal == 'Blue' and #G\.consumeables\.cards \+ G\.GAME\.consumeable_buffer < G\.consumeables\.config\.card_limit (?<post>.*)
'''
position = "at"
line_prepend = '$indent'
payload = '''
-- All in Jest patch
local aij_blue_seal_is_negative = false
if self.seal == 'Blue' or (next(SMODS.find_card("j_aij_warhol")) and self.seal) then
    local ret = SMODS.calculate_context({
        aij_grim_joker_bluepurple_seal = true
    })
    aij_blue_seal_is_negative = ret.aij_grim_joker_bluepurple_seal_negative_mod
end
-- End All in Jest patch
if (self.seal == 'Blue' or (next(SMODS.find_card("j_aij_warhol")) and self.seal)) and (aij_blue_seal_is_negative or (#G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit)) $post
'''
# The Grim Joker (Blue Seals) (2/3) & Sky Trees (1/3)
# Undo buffer change so that non-negative consumables aren't prevented from spawning
# Also, add to buffer a second time if two cards are being created via Sky Trees
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''local card_type = 'Planet'
G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1'''
position = "after"
match_indent = true
payload = '''
-- All in Jest patch
if next(SMODS.find_card("j_aij_sky_trees")) and not aij_blue_seal_is_negative then
    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
end
if aij_blue_seal_is_negative then
    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer - 1 -- Undoes adding to buffer
end
-- End All in Jest patch
'''
# The Grim Joker (Blue Seals) (3/3)
# Applies negative to card if set to be negative
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "local card = create_card(card_type,G.consumeables, nil, nil, nil, nil, _planet, 'blusl')"
position = "after"
match_indent = true
payload = '''
-- All in Jest patch
if aij_blue_seal_is_negative then
    card:set_edition({negative = true}, true)
end
-- End All in Jest patch
'''

# Opening Move (1/1)
# Make first hand show "Will not score" if Opening Move is owned
# CardArea:parse_highlighted()
[[patches]]
[patches.pattern]
target = "cardarea.lua"
pattern = 'G.boss_throw_hand = nil'
position = "after"
match_indent = true
payload = '''
do
    local has_opening_move = next(SMODS.find_card("j_aij_opening_move"))
    if G.GAME.current_round.hands_played <= 0 and has_opening_move then
        G.boss_throw_hand = true
    end
end
'''

# # Currently unused patch, used to be used for splash-like jokers but they now use the relevant calculate context instead
# [[patches]]
# [patches.pattern]
# target = '=[SMODS _ "src/utils.lua"]'
# pattern = "if (G.P_CENTERS[(card.edition or {}).key] or {}).always_scores then return true end"
# position = "before"
# payload = '''
# local has_beanstalk = next(SMODS.find_card("j_aij_beanstalk"))
# if has_beanstalk then
#     if card:get_id() == 11 then
#         return true
#     end
# end
# if next(SMODS.find_card("j_aij_punch_and_judy")) then
#     if card:get_id() == 12 or card:get_id() == 13 then
#         return true
#     end
# end
# '''
# match_indent = true 

# Pace Legendary (1/2)
# Make all rarities the same weight
# SMODS.poll_rarity()
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = "v.weight = v.weight*v.mod"
position = "after"
payload = '''
if next(SMODS.find_card("j_aij_pace")) then
    v.weight = 1
end
'''
match_indent = true 

# Pace Legendary (2/2)
# Make all jokers cost $4
# Card:set_cost()
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.cost = math.max(1, math.floor((self.base_cost + self.extra_cost + 0.5)*(100-G.GAME.discount_percent)/100))"
position = "after" 
match_indent = true
payload = '''
if next(SMODS.find_card("j_aij_pace")) and self.ability.set == 'Joker' then
    self.cost = math.max(1, math.floor((SMODS.find_card("j_aij_pace")[1].ability.extra.price + self.extra_cost + 0.5)*(100-G.GAME.discount_percent)/100))
end
'''

#Multi-Rank stuff
#[[patches]]
#[patches.pattern]
#target = '=[SMODS _ "src/loader.lua"]'
#pattern = "SMODS.Mods = {}"
#position = "before"
#payload = '''
#-- __NFS_READ_MULTI_RANK_PATCHED__
#local function patch_text(txt)
#    txt = txt:gsub(
#        "([%w_.#]+):get_id%(%s*%)%s*%%%s*([%w_.%(%)#]+)%s*==%s*([%w_.%(%)#]+)",
#        "ids_op(%1, \"mod\", %2, %3)"
#    )
#
#    for _, op in ipairs({">=", "<=", "~=", "==", ">", "<"}) do
#        local esc = op:gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])", "%%%1")

 #       txt = txt:gsub(
 #           "([%w_.#]+):get_id%(%s*%)%s*" .. esc .. "%s*([%w_.#]+):get_id%(%s*%)",
 #           "ids_op(%1, \"" .. op .. "\", %2:get_id())"
 #       )

#        txt = txt:gsub(
#            "([%w_.#]+):get_id%(%s*%)%s*" .. esc .. "%s*([%w_.#]+)",
#            "ids_op(%1, \"" .. op .. "\", %2)"
#        )
#    end

#    -- separate for brackets
#    txt = txt:gsub(
#        "([%w_.#]+%b[]):get_id%(%s*%)%s*%%%s*([%w_.%(%)]+)%s*==%s*([%w_.%(%)]+)",
#        "ids_op(%1, \"mod\", %2, %3)"
#    )

#    for _, op in ipairs({">=", "<=", "~=", "==", ">", "<"}) do
#        local esc = op:gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])", "%%%1")
#
#        txt = txt:gsub(
#            "([%w_.#]+%b[]):get_id%(%s*%)%s*" .. esc .. "%s*([%w_.#]+%b[]):get_id%(%s*%)",
#            "ids_op(%1, \"" .. op .. "\", %2:get_id())"
#        )

#        txt = txt:gsub(
#            "([%w_.#]+%b[]):get_id%(%s*%)%s*" .. esc .. "%s*([%w_.%(%)]+)",
#            "ids_op(%1, \"" .. op .. "\", %2)"
#        )
#    end

#    -- insert other_patch_text additions here

#    return txt
#end

#local real_read = NFS.read
#NFS.read = function(path)
#    local content = real_read(path)
#    if not content or not path:match("%.lua$") then return content end
#    return patch_text(content)
#end
#'''
#match_indent = true

#[[patches]]
#[patches.pattern]
#target = '=[SMODS _ "src/loader.lua"]'
#pattern = "-- insert other_patch_text additions here"
#position = "after"
#payload = '''
#txt = txt:gsub(
#    "(pseudorandom%([^%)]+%))%s*([><~=]+)%s*([%w_.#]+)%s*/%s*([%w_.#]+)",
#    "get_probability(%1, \"%2\", %3, %4)"
#)
#'''
#match_indent = true

#[[patches]]
#[patches.pattern]
#target = '=[SMODS _ "src/loader.lua"]'
#pattern = "SMODS.get_optional_features()"
#position = "after"
#payload = '''
#NFS.read = real_read
#'''
#match_indent = true 

#Memory_card
#[[patches]]
#[patches.pattern]
#target = "cardarea.lua"
#pattern = "pseudoshuffle(self.cards, pseudoseed(_seed or 'shuffle'))"
#position = "after"
#payload = '''
#for i = #self.cards, 1, -1 do
#    local card = self.cards[i]
#    if G.GAME.jest_stored_memory_card ~= nil then
#        if card == G.GAME.jest_stored_memory_card then
#            table.remove(self.cards, i)
#            table.insert(self.cards, #self.cards + 1, card)
#        end
#    end
#end
#'''
#match_indent = true


# Circuit Diagram (1/1)
# Move charged cards to the top of the deck after shuffling
# CardArea:shuffle()
[[patches]]
[patches.pattern]
target = "cardarea.lua"
pattern = "pseudoshuffle(self.cards, pseudoseed(_seed or 'shuffle'))"
position = "after"
payload = '''
local has_circuit_diagram = next(SMODS.find_card("j_aij_circuit_diagram"))
if has_circuit_diagram then
    for i = #self.cards, 1, -1 do
        local card = self.cards[i]
        if card.config.center == G.P_CENTERS["m_aij_charged"] then
            table.remove(self.cards, i)
            table.insert(self.cards, #self.cards + 1, card)
        end
    end
end
'''
match_indent = true

# Electric Snow (1/2)
# Prevent round from ending after hand is played (unless final hand is played)
# Game:update_hand_played()
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "if G.GAME.chips - G.GAME.blind.chips >= 0 or G.GAME.current_round.hands_left < 1 then"
position = "before"
match_indent = true
payload = '''
if next(SMODS.find_card("j_aij_electric_snow")) and not (G.GAME.current_round.hands_left < 1) then
    G.STATE = G.STATES.DRAW_TO_HAND
    G.STATE_COMPLETE = false
    return true
end
if G.STATE == G.STATES.NEW_ROUND then
    return true
end
'''
# Electric Snow (2/2)
# Prevent round from ending after boss is disabled (unless final hand is played)
# Blind:disable()
[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = "if self.boss and G.GAME.chips - G.GAME.blind.chips >= 0 then"
position = "before"
match_indent = true
payload = '''
if next(SMODS.find_card("j_aij_electric_snow")) and not (G.GAME.current_round.hands_left < 1) then
    G.STATE = G.STATES.DRAW_TO_HAND
    G.STATE_COMPLETE = false
    return true
end
if G.STATE == G.STATES.NEW_ROUND then
    return true
end
'''
# Electric Snow + Taslisman (1/2)
# Prevent round from ending after hand is played (unless final hand is played)
# As above, but with a pattern for talisman
# Game:update_hand_played()
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "if to_big(G.GAME.chips) >= to_big(G.GAME.blind.chips) or G.GAME.current_round.hands_left < 1 then"
position = "before"
match_indent = true
payload = '''
if next(SMODS.find_card("j_aij_electric_snow")) and not (G.GAME.current_round.hands_left < 1) then
    G.STATE = G.STATES.DRAW_TO_HAND
    G.STATE_COMPLETE = false
    return true
end
if G.STATE == G.STATES.NEW_ROUND then
    return true
end
'''
# Electric Snow (2/2)
# Prevent round from ending after boss is disabled (unless final hand is played)
# As above, but with a pattern for talisman
# Blind:disable()
[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = "if self.boss and to_big(G.GAME.chips) - G.GAME.blind.chips >= to_big(0) then"
position = "before"
match_indent = true
payload = '''
if next(SMODS.find_card("j_aij_electric_snow")) and not (G.GAME.current_round.hands_left < 1) then
    G.STATE = G.STATES.DRAW_TO_HAND
    G.STATE_COMPLETE = false
    return true
end
if G.STATE == G.STATES.NEW_ROUND then
    return true
end
'''

# Guess the Jest (1/2)
# Prevents tooltip for Guess the Jest cards from appearing while hovering over cards in the pack
# Card:hover()
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.facing == 'front' and (not self.states.drag.is or G.CONTROLLER.HID.touch)*" # Find a line inside Card:hover() before the tooltip logic
position = "before"
match_indent = true
payload = '''
-- Prevent tooltip for Guess the Jest cards while in the pack
if (self.ability and self.ability.from_guess_the_jest and self.area == G.pack_cards) or self.ability.jest_got_no_ui then
    return
end
'''

# Guess the Jest (2/2)
# Remove from_guess_the_jest attribute once joker has been selected
# Card:add_to_deck
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.set == 'Enhanced' or self.ability.set == 'Default' then"
position = "before"
match_indent = true
payload = '''
if self.ability and self.ability.from_guess_the_jest and self.ability.set == 'Joker' then
    self.ability.from_guess_the_jest = nil
end
'''

# Line in the Sand (1/3)
# Add card area for Line in the Sand (discarded cards only return at end of ante)
# Game:start_run()
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "self.discard = CardArea("
position = "before"
match_indent = true
payload = '''
self.jest_super_discard = CardArea(
        0, 0,
        CAI.discard_W,CAI.discard_H,
        {card_limit = 1e308, type = 'discard'})
'''

# Line in the Sand (2/3)
# Put discarded cards in super discard area instead of normal discard area
# G.FUNCS.discard_cards_from_highlighted()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = "draw_card(G.hand, G.discard, i*100/highlighted_count, 'down', false, G.hand.highlighted[i])"
position = "at"
payload = '''
local has_line_in_the_sand = next(SMODS.find_card("j_aij_line_in_the_sand"))
if has_line_in_the_sand then
    draw_card(G.hand, G.jest_super_discard, i*100/highlighted_count, 'down', false, G.hand.highlighted[i])
else
    draw_card(G.hand, G.discard, i*100/highlighted_count, 'down', false, G.hand.highlighted[i])
end
'''
match_indent = true

# Line in the Sand (3/3)
# If there are cards removed by line in the sand, return them after boss blind is defeated
# G.FUNCS.draw_from_discard_to_deck()
[[patches]] 
[patches.pattern]
target = "functions/state_events.lua"
pattern = "local discard_count = #G.discard.cards"
position = "before"
payload = '''
if #G.jest_super_discard.cards > 0 and G.GAME.blind.boss then
    local super_discard_count = #G.jest_super_discard.cards
    for i=1, super_discard_count do --draw cards from deck
        draw_card(G.jest_super_discard, G.deck, i*100/super_discard_count,'up', nil ,nil, 0.005, i%2==0, nil, math.max((21-i)/20,0.7))
    end
end
'''
match_indent = true

# Blind Drawn (1/6)
# Set variable for later
# create_UIBox_blind_choice()
[[patches]] 
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = "if not run_info then G.GAME.round_resets.blind_states[G.GAME.blind_on_deck] = 'Select' end"
position = "after"
payload = '''
local aij_has_blind_drawn = next(SMODS.find_card("j_aij_blind_drawn")) and type == 'Boss'
'''
match_indent = true

# Blind Drawn (2/6)
# Replace blind ability description with ???
# create_UIBox_blind_choice()
[[patches]] 
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''
for k, v in ipairs(text_table) do
    blind_desc_nodes[#blind_desc_nodes+1] = {n=G.UIT.R, config={align = "cm", maxw = 2.8}, nodes={
        {n=G.UIT.T, config={text = v or '-', scale = 0.32, colour = disabled and G.C.UI.TEXT_INACTIVE or G.C.WHITE, shadow = not disabled}}
    }}
end
'''
position = "at"
payload = '''
if aij_has_blind_drawn then
    blind_desc_nodes[#blind_desc_nodes+1] = {n=G.UIT.R, config={align = "cm", maxw = 2.8}, nodes={
        {n=G.UIT.T, config={text = "???", scale = 0.32, colour = disabled and G.C.UI.TEXT_INACTIVE or G.C.WHITE, shadow = not disabled}}
    }}
    blind_col = G.C.UI.TEXT_INACTIVE
else
    for k, v in ipairs(text_table) do
        blind_desc_nodes[#blind_desc_nodes+1] = {n=G.UIT.R, config={align = "cm", maxw = 2.8}, nodes={
            {n=G.UIT.T, config={text = v or '-', scale = 0.32, colour = disabled and G.C.UI.TEXT_INACTIVE or G.C.WHITE, shadow = not disabled}}
        }}
    end
end
'''
match_indent = true

# Blind Drawn (3/6)
# Set name of Boss Blind to ???
# create_UIBox_blind_choice()
[[patches]] 
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = ''' {n=G.UIT.R, config={id = 'blind_name',align = "cm", padding = 0.07}, nodes={
    {n=G.UIT.R, config={align = "cm", r = 0.1, outline = 1, outline_colour = blind_col, colour = darken(blind_col, 0.3), minw = 2.9, emboss = 0.1, padding = 0.07, line_emboss = 1}, nodes={
        {n=G.UIT.O, config={object = DynaText({string = loc_name, colours = {disabled and G.C.UI.TEXT_INACTIVE or G.C.WHITE}, shadow = not disabled, float = not disabled, y_offset = -4, scale = 0.45, maxw =2.8})}},
    }},
}},
'''
position = "before"
payload = '''
aij_has_blind_drawn and {n=G.UIT.R, config={id = 'blind_name',align = "cm", padding = 0.07}, nodes={
    {n=G.UIT.R, config={align = "cm", r = 0.1, outline = 1, outline_colour = G.C.UI.TEXT_INACTIVE, colour = darken(G.C.UI.TEXT_INACTIVE, 0.3), minw = 2.9, emboss = 0.1, padding = 0.07, line_emboss = 1}, nodes={
        {n=G.UIT.O, config={object = DynaText({string = "???", colours = {disabled and G.C.UI.TEXT_INACTIVE or G.C.WHITE}, shadow = not disabled, float = not disabled, y_offset = -4, scale = 0.45, maxw =2.8})}},
    }},
}} or
'''
match_indent = true

# Blind Drawn (4/6)
# Hide blind requirement if blind drawn is owned
# Uses regex so it doesn't match with another function + so it works with The Clay blind's thing
# create_UIBox_blind_choice()
[[patches]] 
[patches.regex]
target = "functions/UI_definitions.lua"
pattern = '''(?<pre>function create_UIBox_blind_choice(?:.|\n)*?)
(?<indent>[\t ]*)*\{n=G\.UIT\.T, config=\{text = (?<post>number_format\(blind_amt\),.*?)
'''
position = "at"
payload = '''$pre
$indent{n=G.UIT.T, config={text = aij_has_blind_drawn and "???" or $post
'''

# Blind Drawn (5/6)
# Hide blind reward if blind drawn is owned
# create_UIBox_blind_choice()
[[patches]] 
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = ''' _reward and {n=G.UIT.R, config={align = "cm"}, nodes={
    {n=G.UIT.T, config={text = localize('ph_blind_reward'), scale = 0.35, colour = disabled and G.C.UI.TEXT_INACTIVE or G.C.WHITE, shadow = not disabled}},
    {n=G.UIT.T, config={text = string.rep(localize("$"), blind_choice.config.dollars)..'+', scale = 0.35, colour = disabled and G.C.UI.TEXT_INACTIVE or G.C.MONEY, shadow = not disabled}}
}} or nil,
'''
position = "before"
payload = '''
aij_has_blind_drawn and _reward and {n=G.UIT.R, config={align = "cm"}, nodes={
    {n=G.UIT.T, config={text = localize('ph_blind_reward'), scale = 0.35, colour = disabled and G.C.UI.TEXT_INACTIVE or G.C.WHITE, shadow = not disabled}},
    {n=G.UIT.T, config={text = "???", scale = 0.35, colour = disabled and G.C.UI.TEXT_INACTIVE or G.C.MONEY, shadow = not disabled}}
}} or
'''
match_indent = true

# # Unused patch currently, seemingly does nothing?
# [[patches]] 
# [patches.pattern]
# target = "functions/UI_definitions.lua"
# pattern = '''
# G.GAME.blind:change_dim(1.5,1.5)
# '''
# position = "before"
# payload = '''
# local aij_has_blind_drawn = next(SMODS.find_card("j_aij_blind_drawn")) and type == 'Boss'
# '''
# match_indent = true

# Blind Drawn (6/6)
# Defines the shaders for the hidden blind sprite
# Using regex so it doesn't match with another function
# create_UIBox_blind_choice()
[[patches]] 
[patches.regex]
target = "functions/UI_definitions.lua"
pattern = '''
(?<indent>[\t ]*)function create_UIBox_blind_choice\(.*
(?:.|\n)*?
[\t ]*blind_choice\.animation = .*
'''
position = "after"
line_prepend = '$indent'
payload = '''
  if aij_has_blind_drawn then
      blind_choice.animation = SMODS.create_sprite(0,0, 1.4, 1.4, "aij_blind_drawn_replacement",  { x = 0, y = 0 })
      if blind_choice.config.boss_colour ~= G.C.UI.TEXT_INACTIVE then
          blind_choice.config.aij_old_boss_colour = blind_choice.config.boss_colour
          blind_choice.config.boss_colour = G.C.UI.TEXT_INACTIVE
      end
  else
      if blind_choice.config.aij_old_boss_colour ~= nil then
          blind_choice.config.boss_colour = blind_choice.config.aij_old_boss_colour
          blind_choice.config.aij_old_boss_colour = nil
      end
  end
'''

# # Currently unused patches for planned Aluzinnu joker
#[[patches]]
#[patches.pattern]
#target = "functions/common_events.lua"
#pattern = '''
#local center = pseudorandom_element(_pool, pseudoseed(_pool_key))
#'''
#position = "after"
#match_indent = true
#payload = '''            
#if next(SMODS.find_card("j_aij_aluzinnu")) and pseudorandom('aluzinnu_rate') < 1 + next(SMODS.find_card("j_aij_aluzinnu")) / 4 + next(SMODS.find_card("j_aij_aluzinnu")) then
#    local ran = pseudorandom('aij_aluzinnu',1,2)
#    if ran == 1 then 
#        center = "v_petroglyph"
#    else
#        center = "v_hieroglyph"
#    end
#end
#'''
#
#[[patches]]
#[patches.pattern]
#target = "functions/UI_definitions.lua"
#pattern = '''
#if card.ability_UIBox_table then
#'''
#position = "before"
#match_indent = true
#payload = '''
#if next(SMODS.find_card("j_aij_aluzinnu")) and card.ability ~= nil then
#    if card.ability_UIBox_table and card.ability.name == "Hieroglyph" or card.ability.name == "Petroglyph" then
#        local AUT = card.ability_UIBox_table
#        if AUT.card_type == 'Voucher' then
#            local debuffed = card.debuff
#            local card_type_colour = get_type_colour(card.config.center or card.config, card)
#            local card_type_background = G.C.SET[AUT.card_type] or {0, 1, 1, 1}
#
#            local outer_padding = 0.05
#            local card_type = localize('k_'..string.lower(AUT.card_type))
#
#            local info_boxes = {}
#            local badges = {}
#
#            if AUT.badges.card_type or AUT.badges.force_rarity then
#                badges[#badges + 1] = create_badge(((card.ability.name == 'Pluto' or card.ability.name == 'Ceres' or card.ability.name == 'Eris') and localize('k_dwarf_planet')) or (card.ability.name == 'Planet X' and localize('k_planet_q') or card_type),card_type_colour, nil, 1.2)
#            end
#            if AUT.badges then
#                for k, v in ipairs(AUT.badges) do
#                    badges[#badges + 1] = create_badge(localize(v, "labels"), get_badge_colour(v))
#                end
#            end
#
#            if AUT.info then
#            for k, v in ipairs(AUT.info) do
#                info_boxes[#info_boxes+1] =
#                {n=G.UIT.R, config={align = "cm"}, nodes={
#                {n=G.UIT.R, config={align = "cm", colour = lighten(G.C.JOKER_GREY, 0.5), r = 0.1, padding = 0.05, emboss = 0.05}, nodes={
#                info_tip_from_rows(v, v.name),
#                }}
#            }}
#            end
#            end
#
#            return {n=G.UIT.ROOT, config = {align = 'cm', colour = G.C.CLEAR}, nodes={
#            {n=G.UIT.C, config={align = "cm", func = 'show_infotip',object = Moveable(),ref_table = next(info_boxes) and info_boxes or nil}, nodes={
#                {n=G.UIT.R, config={padding = outer_padding, r = 0.12, colour = lighten(G.C.JOKER_GREY, 0.5), emboss = 0.07}, nodes={
#                {n=G.UIT.R, config={align = "cm", padding = 0.07, r = 0.1, colour = adjust_alpha(card_type_background, 0.8)}, nodes={
#                    name_from_rows(AUT.name, is_playing_card and G.C.WHITE or nil),
#                    {n=G.UIT.R, config={align = "cm", colour = empty and G.C.CLEAR or G.C.UI.BACKGROUND_WHITE, r = 0.1, padding = 0.04, minw = 2, minh = 0.8, emboss = not empty and 0.05 or nil, filler = true}, nodes={
#                        {n=G.UIT.C, config={align = "cm", maxw = maxw}, nodes={
#                            {n=G.UIT.T, config={text = "-1 ",colour = G.C.FILTER, scale = 0.32}}
#                        }},
#                        {n=G.UIT.C, config={align = "cm", maxw = maxw}, nodes={
#                            {n=G.UIT.T, config={text = "Ante",colour = G.C.UI.TEXT_DARK, scale = 0.32}}
#                        }},
#                    }},
#                    badges[1] and {n=G.UIT.R, config={align = "cm", padding = 0.03}, nodes=badges} or nil,
#                }}
#                }}
#            }},
#            }}
#        end
#    end
#end
#'''

# # Currently unused patches for planned Event Horizon joker
#[[patches]]
#[patches.pattern]
#target = "functions/common_events.lua"
#pattern = '''
#if v.yes_pool_flag and not G.GAME.pool_flags[v.yes_pool_flag] then add = nil end
#'''
#position = "after"
#match_indent = true
#payload = '''
#
#local has_event_horizon = false
#if G.jokers ~= nil and G.jokers.cards then
#    if next(SMODS.find_card('j_aij_event_horizon')) then
#        has_event_horizon = true
#    end
#end
#if has_event_horizon then
#    if v.name == 'Black Hole' then
#        add = true
#    end
#end
#'''
#
#[[patches]]
#[patches.pattern]
#target = "functions/common_events.lua"
#pattern = '''
#if pseudorandom('soul_'.._type..G.GAME.round_resets.ante) > 0.997 then
#    forced_key = 'c_black_hole'
#end
#'''
#position = "after"
#match_indent = true
#payload = '''
#
#local has_event_horizon = false
#if G.jokers ~= nil and G.jokers.cards then
#    if next(SMODS.find_card('j_aij_event_horizon')) then
#        has_event_horizon = true
#    end
#end
#if has_event_horizon then
#    if pseudorandom('soul_'.._type..G.GAME.round_resets.ante) > 0.923 then
#        forced_key = 'c_black_hole'
#    end
#end
#'''

###########################
    # BLUE SEAL FIXES #
###########################

# Moon Cards (1/2)
# Prevent blue seals from generating moons
# Card:get_end_of_round_effect()
[[patches]]
[patches.regex]
target = "card.lua"
pattern = '''(?<indent>[\t ]*)if v.config.hand_type == G.GAME.last_hand_played (?<post>.*)'''
position = "at"
line_prepend = '$indent'
payload = '''if v.config.hand_type == G.GAME.last_hand_played and not v.config.moon $post'''

# Sky Trees (2/3)
# Creates two moon cards instead of a planet card
# Card:get_end_of_round_effect()
[[patches]] 
[patches.pattern]
target = "card.lua"
pattern = '''
if _planet == 0 then _planet = nil end
'''
position = "before"
match_indent = true
payload = '''
if next(SMODS.find_card("j_aij_sky_trees")) then
    local _other_planet = 0
    for k, v in pairs(G.P_CENTER_POOLS.Planet) do
        if v.config.moon and v.config.hand_type == G.GAME.last_hand_played and v.config.mult then
            _planet = v.key
        end
        if v.config.moon and v.config.hand_type == G.GAME.last_hand_played and v.config.chips then
            _other_planet = v.key
        end
    end
    if _other_planet == 0 then _other_planet = nil end
    local cardt = create_card(card_type,G.consumeables, nil, nil, nil, nil, _other_planet, 'blusl')
    if aij_blue_seal_is_negative then -- For The Grim Joker
        cardt:set_edition({negative = true}, true)
    end
    cardt:add_to_deck()
    G.consumeables:emplace(cardt)
end
'''

# Sky Trees (3/3)
# Show "+2 Moons" message instead of "+1 Planet"
# Card:get_end_of_round_effect()
[[patches]] 
[patches.regex]
target = "card.lua"
pattern = '''(?<indent>[\t ]*)(?<pattern>card_eval_status_text\(self, 'extra', nil, nil, nil, \{message = localize\('k_plus_planet'\).*)'''
position = "at"
line_prepend = '$indent    '
payload = '''
if next(SMODS.find_card("j_aij_sky_trees")) then
    card_eval_status_text(self, 'extra', nil, nil, nil, {message = localize('k_aij_plus_two_moons'), colour = G.C.SECONDARY_SET.Planet})
else
    $pattern
end
'''

#--------------------------------#
    # END OF BLUE SEAL FIXES #
#--------------------------------#

# Moon Cards (2/2) + Astrologer Joker
# Offsets abundance of moons by making all other planets appear x3 as often, done mainly for crossmod purposes
# Other special All in Jest planets are listed as well, making them appear 1/3 as much as other standard planets
# (Dark Star, Rogue Planet, and Sol)
# Also handles Astrologer joker (only mult/chip moons appear on odd/even antes)
# create_card()
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''center = pseudorandom_element(_pool, pseudoseed(_pool_key))'''
position = "before"
match_indent = true
payload = '''
do -- All in Jest Patch
    if _type == 'Planet' then
        local unboosted_weight_planet_keys = {
            ['c_mercury'] = true, ['c_aij_vulcanoid'] = true, ['c_aij_phaethon'] = true,
            ['c_venus'] = true, ['c_aij_zoozve'] = true, ['c_aij_2013_nd15'] = true, 
            ['c_earth'] = true, ['c_aij_luna'] = true, ['c_aij_kamooalewa'] = true,
            ['c_mars'] = true, ['c_aij_phobos'] = true, ['c_aij_deimos'] = true,
            ['c_jupiter'] = true, ['c_aij_europa'] = true, ['c_aij_callisto'] = true, 
            ['c_saturn'] = true, ['c_aij_titan'] = true, ['c_aij_iapetus'] = true,
            ['c_uranus'] = true, ['c_aij_umbriel'] = true, ['c_aij_oberon'] = true,
            ['c_neptune'] = true, ['c_aij_triton'] = true, ['c_aij_proteus'] = true, 
            ['c_pluto'] = true, ['c_aij_nix'] = true, ['c_aij_charon'] = true,
            ['c_planet_x'] = true, ['c_aij_planet_nine'] = true, ['c_aij_nibiru'] = true,
            ['c_ceres'] = true, ['c_aij_pallas'] = true, ['c_aij_2000_eu16'] = true, 
            ['c_eris'] = true, ['c_aij_dysnomia'] = true, ['c_aij_kuiper'] = true,
            
            ['c_paperback_quaoar'] = true, ['c_aij_paper_weywot'] = true, ['c_aij_paper_namaka'] = true,
            ['c_paperback_haumea'] = true, ['c_aij_paper_ilmare'] = true, ['c_aij_paper_salacia'] = true,
            ['c_paperback_sedna'] = true, ['c_aij_paper_ixion'] = true, ['c_aij_paper_hiiaka'] = true,
            ['c_paperback_makemake'] = true, ['c_aij_paper_varda'] = true, ['c_aij_paper_mk2'] = true,
            
            ['c_bunc_quaoar'] = true, ['c_aij_bunc_weywot'] = true, ['c_aij_bunc_namaka'] = true,
            ['c_bunc_haumea'] = true, ['c_aij_bunc_ilmare'] = true, ['c_aij_bunc_salacia'] = true,
            ['c_bunc_sedna'] = true, ['c_aij_bunc_ixion'] = true, ['c_aij_bunc_hiiaka'] = true,
            ['c_bunc_makemake'] = true, ['c_aij_bunc_varda'] = true, ['c_aij_bunc_mk2'] = true,

            ['c_aij_dark_star'] = true, ['c_aij_sol'] = true, ['c_aij_rogue'] = true,
        }
        if _pool and #_pool > 0 then
            local weighted_pool = {}
            for i = 1, #_pool do
                local item = _pool[i] 
                local item_key = nil
                if type(item) == 'string' then
                    item_key = item
                elseif type(item) == 'table' and item.key then 
                    item_key = item.key
                end

                if item_key then
                    local weight = 3
                    if unboosted_weight_planet_keys[item_key] then
                        weight = 1 
                    end
                    -- Add the original item key from the pool 'weight' times
                    for w = 1, weight do
                        table.insert(weighted_pool, item_key) 
                    end
                else
                    -- Fallback if we somehow can't determine the key
                    table.insert(weighted_pool, item)
                end
            end
                    
            if #weighted_pool > 0 then 
                _pool = weighted_pool
            end
        end
        if next(SMODS.find_card('j_aij_astrologer')) then
            local cur_pool = {}
            for i = 1, #_pool do
                local item = _pool[i] 
                local item_key = nil
                if type(item) == 'string' then
                    item_key = item
                elseif type(item) == 'table' and item.key then 
                    item_key = item.key
                end

                if item_key then
                    local planet_center = G.P_CENTERS[item_key]
                    if planet_center and planet_center.key == item_key then
                        if (G.GAME.round_resets.ante % 2) == 0 then
                            if planet_center.config and planet_center.config.chips and planet_center.config.moon then
                                table.insert(cur_pool, item)
                            end
                        elseif (G.GAME.round_resets.ante % 2) == 1 then
                            if planet_center.config and planet_center.config.mult and planet_center.config.moon then
                                table.insert(cur_pool, item)
                            end
                        end
                    end
                else
                    table.insert(cur_pool, item)
                end
            end

            if #cur_pool > 0 then 
                _pool = cur_pool
            end
        end
    end
end -- End of All in Jest Patch
'''

# Handle aij_weight on objects
# aij_weight has to be a positive or negative integer;
# if negative N, this effectively means 1/N weight
# Currently only used for special moon cards
# get_current_pool()
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''if _pool_size == 0 then'''
position = "before"
match_indent = true
payload = '''
do -- All in Jest Patch
    local aij_weight_map = {} -- maps key -> aij_weight
    local aij_weight_multi = 1 -- multiplies all weights, compensating for 1/N weights
    for k, v in ipairs(_starting_pool) do
        if v.aij_weight and type(v.aij_weight) == 'function' then
            local w = v:aij_weight()
            if w then
                aij_weight_map[v.key] = w
                if w < 0 then
                    if aij_weight_multi % math.abs(w) ~= 0 then
                        -- I'm too lazy to calculate the lcm
                        aij_weight_multi = aij_weight_multi * math.abs(w)
                    end
                end
            end
        end
    end
    local temp_pool = {}
    for k, v in ipairs(_pool) do
        if v ~= "UNAVAILABLE" then
            local w = aij_weight_map[v] or 1
            local adjusted_w
            if w < 0 then
                assert(aij_weight_multi % math.abs(w) == 0)
                adjusted_w = aij_weight_multi / math.abs(w)
            else
                adjusted_w = aij_weight_multi * w
            end
            for i = 1, adjusted_w-1 do -- We subtract 1 as the card should already be in the pool once
                temp_pool[#temp_pool + 1] = v
            end
        end
    end
    for _, v in ipairs(temp_pool) do
        _pool[#_pool + 1] = v
        _pool_size = _pool_size + 1
    end
end -- End of All in Jest Patch
'''

# Touchstone (1/1)
# Adds the touchstone forecast on the hover deck preview
[[patches]]
[patches.regex]
target = '=[SMODS _ "src/overrides.lua"]'
pattern = '''(?<indent>[\t ]*)wheel_flipped_text and \{(.|\n)*?or nil,'''
position = "after"
line_prepend = "$indent"
payload = '''

(next(SMODS.find_card('j_aij_touchstone')) or next(SMODS.find_card('j_aij_peeping_tom'))) and AllInJest.touchstone_deck_preview() or nil,
'''

# When saving a run, save all data in G.all_in_jest as direct children of G
# save_run()
[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = "local cardAreas = {}"
position = "before"
match_indent = true
payload = '''
if G.all_in_jest then
    for k, v in pairs(G) do -- I dont think this is used anymore?
        if string.sub(k, 1, 13) == 'G_all_in_jest' then
            local key = string.gsub(k, 'G_all_in_jest', '')
            G.all_in_jest = G.all_in_jest or {}
            G.all_in_jest[key] = v
        end
    end
    for k, v in pairs(G.all_in_jest) do
        G['G_all_in_jest'..k] = v
    end
end
'''

# Also adds Sprites needed for patches and a new sticker/indicator for perma debuff
# Also handles moving all data in G_all_in_jest as children of G.all_in_jest when loading a run
# Keeping in one patch to ensure the G_all_in_jest stuff always happens last
# Using CardAreas so that reloading a run works properly
# Game:start_run
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "self.discard = CardArea("
position = "before"
match_indent = true
payload = '''
self.all_in_jest = self.all_in_jest or {}
self.all_in_jest.patches_sprites = {}
self.all_in_jest.extra_card_sprites = {}
G.all_in_jest.extra_card_sprites['Mark_of_the_Spear'] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=9,y=2})
G.all_in_jest.patches_sprites["Other"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=0,y=2})
G.all_in_jest.patches_sprites["Hearts"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=2,y=2})
G.all_in_jest.patches_sprites["hc_Hearts"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=1,y=3})
G.all_in_jest.patches_sprites["Clubs"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=1,y=2})
G.all_in_jest.patches_sprites["hc_Clubs"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=0,y=3})
G.all_in_jest.patches_sprites["Diamonds"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=3,y=2})
G.all_in_jest.patches_sprites["hc_Diamonds"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=2,y=3})
G.all_in_jest.patches_sprites["Spades"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=4,y=2})
G.all_in_jest.patches_sprites["hc_Spades"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=3,y=3})
G.all_in_jest.patches_sprites["paperback_Stars"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=5,y=2})
G.all_in_jest.patches_sprites["hc_paperback_Stars"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=4,y=3})
G.all_in_jest.patches_sprites["paperback_Crowns"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=6,y=2})
G.all_in_jest.patches_sprites["hc_paperback_Crowns"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=5,y=3})
G.all_in_jest.patches_sprites["bunc_Halberds"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=6,y=3})
G.all_in_jest.patches_sprites["hc_bunc_Halberds"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=8,y=3})
G.all_in_jest.patches_sprites["bunc_Fleurons"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=7,y=3})
G.all_in_jest.patches_sprites["hc_bunc_Fleurons"] = SMODS.create_sprite(0,0,G.CARD_W,G.CARD_H,"aij_enhancements_atlas", {x=9,y=3})

for k, v in pairs(G) do
    if string.sub(k, 13) == 'G_all_in_jest' then
        local key = string.gsub(k, 'G_all_in_jest', '')
        G.all_in_jest = G.all_in_jest or {}
        G.all_in_jest[key] = v
    end
end
'''

# Advanced Copiers (1/5)
# Allows passing specific variables to the info_queue, so joker tooltips aren't just default stats
# This is for vanilla jokers. Needs separate patches for vanilla and modded jokers.
# generate_card_ui()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "specific_vars = ret[1]"
position = "after"
match_indent = true
payload = '''
specific_vars = _c.specific_vars or specific_vars
if specific_vars ~= nil and specific_vars.aij_multi_copier_card then
    local copier_card = specific_vars.aij_multi_copier_card
    local new_ability = specific_vars.aij_multi_copier_card_ability

    ret = {Card.generate_UIBox_ability_table({ area = copier_card.area, ability = new_ability, config = { center = G.P_CENTERS[new_ability.key] }, bypass_lock = true}, true)}

    new_ability[copier_card.config.center.key .. "_compat_ui"] = new_ability[copier_card.config.center.key .. "_compat_ui"] or ''
    new_ability[copier_card.config.center.key .. "_compat_check"] = nil
    local compatible = G.P_CENTERS[new_ability.key][copier_card.config.center.key .. "_compat"]
    compatible = compatible ~= false
    local copier_compat = (copier_card.area and copier_card.area == G.jokers) and {
        {n=G.UIT.C, config={align = "tm", minh = 0.4}, nodes={
            {n=G.UIT.C, config={align = "m", colour = compatible and mix_colours(G.C.GREEN, G.C.JOKER_GREY, 0.8) or mix_colours(G.C.RED, G.C.JOKER_GREY, 0.8), r = 0.05, padding = 0.06}, nodes={
                {n=G.UIT.T, config={text = ' ' .. (compatible and localize('k_compatible') or localize('k_incompatible')) .. ' ', colour = G.C.UI.TEXT_LIGHT, scale = 0.32*0.8}},
            }}
        }}
    } or nil
    desc_nodes[#desc_nodes + 1] = copier_compat
end
'''
# Advanced Copiers (2/5)
# Allows passing specific variables to the info_queue, so joker tooltips aren't just default stats
# This is for modded jokers. Needs separate patches for vanilla and modded jokers.
# SMODS.Center:generate_ui()
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/game_object.lua"]'
pattern = '''
local target = {
    type = 'descriptions',
    key = self.key,
    set = self.set,
    nodes = desc_nodes,
    AUT = full_UI_table,
    vars =
        specific_vars or {}
}
'''
position = "after"
match_indent = true
payload = '''
-- All in Jest
if target.vars.aij_multi_copier_card then
    card = target.vars.aij_multi_copier_card
    local index = target.vars.aij_multi_copier_card_index
    local new_ability = target.vars.aij_multi_copier_card_ability
    
    if card.added_to_deck then
        All_in_Jest.hotswap_copied_ability(card, index)
    else
        All_in_Jest.set_copied_ability(card, G.P_CENTERS[target.key], nil, new_ability)
    end

    new_ability[card.config.center.key .. "_compat_ui"] = new_ability[card.config.center.key .. "_compat_ui"] or ''
    new_ability[card.config.center.key .. "_compat_check"] = nil
    local compatible = G.P_CENTERS[new_ability.key][card.config.center.key .. "_compat"]
    compatible = compatible ~= false
    local main_end = (card.area and card.area == G.jokers) and {
        {n=G.UIT.C, config={align = "tm", minh = 0.4}, nodes={
            {n=G.UIT.C, config={align = "m", colour = compatible and mix_colours(G.C.GREEN, G.C.JOKER_GREY, 0.8) or mix_colours(G.C.RED, G.C.JOKER_GREY, 0.8), r = 0.05, padding = 0.06}, nodes={
                {n=G.UIT.T, config={text = ' ' .. (compatible and localize('k_compatible') or localize('k_incompatible')) .. ' ', colour = G.C.UI.TEXT_LIGHT, scale = 0.32*0.8}},
            }}
        }}
    } or nil
    desc_nodes[#desc_nodes + 1] = main_end

    target.vars.aij_multi_copier_card = nil
    target.vars.aij_multi_copier_card_index = nil
    target.vars.aij_multi_copier_card_ability = nil

    G.E_MANAGER:add_event(Event({
        func = function()
            All_in_Jest.set_copied_ability(card, {config = {}})
            return true
        end
    }))
end
if target.vars.aij_copier_card then
    card = target.vars.aij_copier_card
    target.vars.aij_copier_card = nil
end
-- End of All in Jest patch
'''
# Advanced Copiers (3/5)
# Fixes an SMODs bug where it tries to access loc_vars incorrectly for formatting the joker's name (1/2)
# generate_card_ui()
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''_c:generate_ui(info_queue, card, desc_nodes, specific_vars, full_UI_table)'''
position = "before"
match_indent = true
payload = '''
local card = _c.specific_vars and (_c.specific_vars.aij_elder or _c.specific_vars.aij_multi_copier_card or _c.specific_vars.aij_copier_card) or card
'''
# Advanced Copiers (4/5)
# Fixes an SMODs bug where it tries to access loc_vars incorrectly for formatting the joker's name (2/2)
# generate_card_ui()
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''localize{type = 'name', key = key, set = set, nodes = desc_nodes.name_styled, fixed_scale = 0.63, no_pop_in = true, no_shadow = true, y_offset = 0, no_spacing = true, no_bump = true, vars = (_c.create_fake_card and _c.loc_vars and (_c:loc_vars({}, _c:create_fake_card()) or {}).vars) or {colours = {}}} '''
position = "at"
match_indent = true
payload = '''
localize{type = 'name', key = key, set = set, nodes = desc_nodes.name_styled, fixed_scale = 0.63, no_pop_in = true, no_shadow = true, y_offset = 0, no_spacing = true, no_bump = true, vars = (_c.create_fake_card and _c.loc_vars and (_c:loc_vars({}, card or _c:create_fake_card()) or {}).vars) or {colours = {}}}  -- All in Jest overrides
'''
# Advanced Copiers (5/5)
# Fixes a nice SMODs issue where Oops! All sixes is refered to by its key rather than ability name (like other vanilla jokers)
# Card:calculate_joker
[[patches]] 
[patches.regex]
target = "card.lua"
pattern = '''(?<indent>[\t ]*)elseif (?<precond>.*?) self.config.center_key == 'j_oops' (?<postcond>.*?)'''
line_prepend = "$indent"
position = "at"
payload = '''elseif $precond self.ability.name == 'Oops! All 6s' $postcond'''

# Patch to make all instances of "destroy" red
# Just hooks into a function in functions.lua
# init_localization()
[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
pattern = "if not center.text then else"
position = 'after'
match_indent = true
payload = '''
-- All in Jest start
if All_in_Jest_format_destroy then
    center.text = All_in_Jest_format_destroy(center.text)
end
-- All in Jest end
'''

# Patch to fix already highlighted cards being re-highlighted and making erroneous sound
# Can't do this in the calculation code because then it would be too early or too late to stop the sound without messing something else up
# Done for Right Angle joker
# highlight_card()
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''func = function()
    card:highlight(highlight)
    play_sound('cardSlide1', 0.85 + percent*0.2)
    return true
end'''
position = 'at'
match_indent = true
payload = '''
-- All in Jest overriden
func = function()
    local aij_sound_should_play = (highlight and not card.highlighted) or (not highlight and card.highlighted)
    card:highlight(highlight)
    if aij_sound_should_play then
        play_sound('cardSlide1', 0.85 + percent*0.2)
    end
    return true
end
-- End of All in Jest overriden
'''


# Patch for Magick Joker and Red Sky
# Turns +chips into +mult within the score_card function, rather than trying to do it with a calculation function
# eval_card()
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''-- TARGET: main scoring on played cards'''
position = 'before'
match_indent = true
payload = '''
do -- All in Jest - Magick Joker and Red Sky
    local has_magick_joker = next(SMODS.find_card("j_aij_magick_joker"))
    local has_red_sky = next(SMODS.find_card("j_aij_red_sky"))
    local card_has_chips = (ret.playing_card.chips or 0) > 0
    if card_has_chips then
        if has_red_sky and (G.GAME.current_round.hands_played == 0 or G.GAME.current_round.hands_left == 0) then
            ret.playing_card.mult = ret.playing_card.mult or 0
            ret.playing_card.mult = ret.playing_card.mult + ret.playing_card.chips
            ret.playing_card.chips = 0
            G.E_MANAGER:add_event(Event({func = function()
                for _, red_sky in ipairs(SMODS.find_card("j_aij_red_sky")) do
                    red_sky:juice_up(0.6, 0.1)
                end
                return true
            end }))
        elseif G.play ~= nil and has_magick_joker then
            local required_suit = G.GAME.current_round.jest_magick_joker_card and G.GAME.current_round.jest_magick_joker_card.suit
            if card:is_suit(required_suit) then
                ret.playing_card.mult = ret.playing_card.mult or 0
                ret.playing_card.mult = ret.playing_card.mult + ret.playing_card.chips
                ret.playing_card.chips = 0
                G.E_MANAGER:add_event(Event({func = function()
                    for _, magick_joker in ipairs(SMODS.find_card("j_aij_magick_joker")) do
                        magick_joker:juice_up(0.6, 0.1)
                    end
                    return true
                end }))
            end
        end
    end
end -- end All in Jest
'''

# Fix a crash if you call G.FUNCS.use_card multiple times in quick succession
# G.FUNCS.use_card
[[patches]]
[patches.regex]
target = 'functions/button_callbacks.lua'
pattern = "G\\.(.*?)\\.alignment\\.offset\\.y = G\\.(.*?)\\.alignment\\.offset\\.py"
position = 'at'
payload = 'G.$1.alignment.offset.y = G.$1.alignment.offset.py or G.$1.alignment.offset.y'

# Fix a crash if a voucher card is used via G.FUNCS.use_card outside the shop
# G.FUNCS.use_card
[[patches]]
[patches.regex]
target = 'functions/button_callbacks.lua'
pattern = " if card\\.ability\\.set == 'Voucher' (.*)"
position = 'at'
payload = " if card.ability.set == 'Voucher' and G.shop $1"



############################################
    # Patches related to tags in shops #
############################################

# Shop Tags (1/10)
# Make shop tags always purchaseable
# G.FUNCS.check_for_buy_space()
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "if card.ability.set ~= 'Voucher' and"
position = "before"
payload = '''
if card.ability.set == 'Tag' then
    return true
end
'''
match_indent = true
# Shop Tags (2/10)
# Add a new card area to the shop for selling tags
# G.UIDEF.shop()
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = "G.shop_booster =*"
position = 'before'
match_indent = true
payload = '''
G.shop_aij_tags = CardArea(
    G.hand.T.x+0,
    G.hand.T.y+G.ROOM.T.y + 9,
    0.8,
    1.15*G.CARD_H, 
    {card_limit = 2, type = 'shop', highlight_limit = 1, card_w = 0.8})

if All_in_Jest.show_shop_aij_tags() then
    G.shop_vouchers.T.w = G.shop_vouchers.T.w - G.shop_aij_tags.T.w - 0.15 -- The 0.15 accounts for padding
end

'''
# Shop Tags (3/10)
# G.UIDEF.deck_preview
# Only make the tag area in the shop appear if any tags are for sale
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''{n=G.UIT.C, config={align = "cm", padding = 0.15, r=0.2, colour = G.C.L_BLACK, emboss = 0.05}, nodes={
  {n=G.UIT.O, config={object = G.shop_booster}},
}},'''
position = 'after'
match_indent = true
payload = '''
All_in_Jest.show_shop_aij_tags() and {n=G.UIT.C, config={align = "cm", padding = 0.15, r=0.2, colour = G.C.L_BLACK, emboss = 0.05}, nodes={
  {n=G.UIT.O, config={object = G.shop_aij_tags}},
}} or nil,
'''
# Shop Tags (4/10)
# G.UIDEF.card_focus_ui
# Make tags purchaseable via controller
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''if card.area == G.shop_booster and G.shop_booster*'''
position = 'before'
match_indent = true
payload = '''
if card.area == G.shop_aij_tags and G.shop_aij_tags then
    base_attach.children.buy = G.UIDEF.card_focus_button{
        card = card, parent = base_attach, type = 'buy',
        func = 'can_buy', button = 'buy_from_shop', card_width = card_width * 2
    }
end
'''
# Shop Tags (5/10)
# Card:load()
## Correctly load tags in shop as cards
[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = 'self.config.center = G.P_CENTERS[self.config.center_key]'
position = "after"
match_indent = true
payload = '''
if cardTable.aij and cardTable.aij.tag then
    self.config.tag = Tag('tag_uncommon')
    self.config.tag:load(cardTable.aij.tag)
    self.config.tag.from_load = nil
    self.config.center_key = self.config.tag.key
    self.config.center = G.P_TAGS[self.config.tag.key]
    self.config.center.atlas = self.config.center.atlas or "tags"

    self.config.center.set_card_type_badge = function(self, card, badges)
        badges[#badges+1] = create_badge(localize('k_tag'), G.C.SECONDARY_SET.Planet, G.C.WHITE, 1.2 )
    end
end
'''
# Shop Tags (6/10)
# Card:load
# Set size of shop tag sprites on game reload
[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''
self.VT.h = self.T.*
self.VT.w = self.T.*
'''
position = "before"
match_indent = true
payload = '''
if cardTable.aij and cardTable.aij.tag then
    self.T.w, self.T.h = 0.8, 0.8
end
'''
# Shop Tags (7/10)
# Game:update_shop
# Make shop tags re-appear on game reload
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''if G.load_shop_booster then '''
position = 'before'
match_indent = true
payload = '''if G.load_shop_aij_tags then 
    nosave_shop = true
    G.shop_aij_tags:load(G.load_shop_aij_tags)
    for k, v in ipairs(G.shop_aij_tags.cards) do
        create_shop_card_ui(v, 'Tag', G.shop_aij_tags)
        v:start_materialize()
    end
    G.load_shop_aij_tags = nil
end

'''
# Shop Tags (8/10)
# Card:generate_UIBox_ability_table
# Proper Shop Tag Text Generation
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "return generate_card_ui(self.config.center, nil, loc_vars, card_type, badges, hide_desc, main_start, main_end, self)"
position = "before"
match_indent = true
payload = '''
if self.ability.is_aij_shop_tag then 
    local name_to_check, alt_loc_vars = self.name, nil
    if name_to_check == 'Orbital Tag' then alt_loc_vars = {
        (self.ability.orbital_hand == '['..localize('k_poker_hand')..']') and self.ability.orbital_hand or localize(self.ability.orbital_hand, 'poker_hands'), self.ability.levels}
    end
    return generate_card_ui(G.P_TAGS[self.config.center.key], nil, alt_loc_vars or loc_vars, (self.hide_ability) and 'Undiscovered' or 'Tag', badges, (self.hide_ability), nil, nil, self) 
end
'''

# Shop Tags (9/10)
# Tag:get_uibox_table
# Make skip tag show correctly in the shop (by default it adds one to the tag, now it won't do so if in shop/pack)
[[patches]]
[patches.regex]
target = "tag.lua"
pattern = '''elseif name_to_check == 'Skip Tag' then loc_vars = \{self\.config\.skip_bonus, self\.config\.skip_bonus\*\(\(G\.GAME\.skips or 0\)\+(.*?)\)\}'''
position = "at"
payload = '''
elseif name_to_check == 'Skip Tag' then loc_vars = {self.config.skip_bonus, self.config.skip_bonus*((G.GAME.skips or 0)+(G.STATE == G.STATES.SHOP and 0 or $1))}
'''
# Shop Tags (10/10)
# G.FUNCS.buy_from_shop
# Add tag when purchases and immediately trigger it if applicable
[[patches]] 
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "elseif e.config.id ~= 'buy_and_use' then"
position = "before"
payload = '''
elseif c1.ability.set == 'Tag' then
    local temptag = c1.config.tag
    add_tag(temptag)
    c1:remove()
    G.E_MANAGER:add_event(Event({
        func = function()
            for i = 1, #G.GAME.tags do
              G.GAME.tags[i]:apply_to_run({type = 'immediate'})
            end
            for i = 1, #G.GAME.tags do
              if G.GAME.tags[i]:apply_to_run({type = 'new_blind_choice'}) then break end
            end
            return true
        end
    })) 
'''
match_indent = true

#-------------------------------------------------#
    # End of patches related to tags in shops #
#-------------------------------------------------#

# Joker Perma stuff
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if vars_only then return loc_vars, main_start, main_end end"
position = "before"
match_indent = true
payload = '''
-- Joker Perma stuff
if self.ability.set == 'Joker' then
    loc_vars = loc_vars or {}
    if self.ability.perma_bonus then
        loc_vars.bonus_chips = self.ability.perma_bonus ~= 0 and self.ability.perma_bonus or nil
    end
    if self.ability.perma_mult then
        loc_vars.bonus_mult = self.ability.perma_mult ~= 0 and self.ability.perma_mult or nil
    end
    if self.ability.perma_x_mult then
        loc_vars.bonus_x_mult = self.ability.perma_x_mult ~= 0 and (self.ability.perma_x_mult + 1) or nil
    end
    if self.ability.perma_p_dollars then
        loc_vars.bonus_p_dollars = self.ability.perma_p_dollars ~= 0 and self.ability.perma_p_dollars or nil
    end
    if self.ability.perma_x_chips then
        loc_vars.bonus_x_chips = self.ability.perma_x_chips ~= 0 and (self.ability.perma_x_chips + 1) or nil
    end
end
'''
# Perma Joker stuff Locaization
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if specific_vars and specific_vars.sticker then info_queue[#info_queue+1] = {key = string.lower(specific_vars.sticker)..'_sticker', set = 'Other'} end"
position = "after"
match_indent = true
payload = '''
if _c.generate_ui and type(_c.generate_ui) == 'function' then
    if specific_vars and specific_vars.bonus_chips then
        localize{type = 'other', key = 'card_extra_chips', nodes = desc_nodes, vars = {SMODS.signed(specific_vars.bonus_chips)}}
    end
    SMODS.localize_perma_bonuses(specific_vars, desc_nodes)
end
'''
# After Vanilla Jokers
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "localize{type = 'descriptions', key = _c.key, set = _c.set, nodes = desc_nodes, vars = specific_vars or {}}"
position = "after"
match_indent = true
payload = '''
if specific_vars and specific_vars.bonus_chips then
    localize{type = 'other', key = 'card_extra_chips', nodes = desc_nodes, vars = {SMODS.signed(specific_vars.bonus_chips)}}
end
SMODS.localize_perma_bonuses(specific_vars, desc_nodes)
'''
# Perma Joker Trigger stuff
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = "for _, key in ipairs({'jokers', 'retriggers'}) do"
position = "before"
payload = '''
for _, key in ipairs({'perma_joker_triggers'}) do
    SMODS.calculate_effect_table_key(effect_table, key, card, ret)
end
'''
match_indent = true 

# Lets multiple cards be forced selected
# Needed for Alien Joker + Cerulean Bell
# CardArea:update()
[[patches]]
[patches.regex]
target = "cardarea.lua"
pattern = '''if v\.ability\.forced_selection and not self\.highlighted\[1\] (?<post>.*)'''
position = "at"
payload = 'if v.ability.forced_selection and not v.highlighted $post'

# Set rerolls to zero cost if reroll cost would be below zero
# Needed now that there are multiple stacking effects that can reduce reroll costs
# calculate_reroll_cost()
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "G.GAME.current_round.reroll_cost = (G.GAME.round_resets.temp_reroll_cost or G.GAME.round_resets.reroll_cost) + G.GAME.current_round.reroll_cost_increase"
position = "at"
match_indent = true
payload = '''G.GAME.current_round.reroll_cost = (G.GAME.round_resets.temp_reroll_cost or math.max(0, G.GAME.round_resets.reroll_cost)) + G.GAME.current_round.reroll_cost_increase'''


# Add context before blind is set
# Used by Fall of Count Chaligny
# Blind:set_blind()
[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = "self.in_blind = true"
position = "after"
match_indent = true
payload = 'SMODS.calculate_context({aij_before_setting_blind = true, blind = G.GAME.round_resets.blind})'


# Card:update
# Makes blueprint-like copiers show the correct compatability to joker.png style copiers 
[[patches]] 
[patches.regex]
target = "card.lua"
pattern = '''(?<indent>[\t ]*)if other_joker and other_joker ~= self and (?<cond>.*?) then'''
line_prepend = "$indent"
position = "at"
payload = '''local aij_blueprint_compatible = other_joker and (other_joker.ability.aij_blueprint_compat or $cond)
if other_joker and other_joker ~= self and aij_blueprint_compatible then'''

# function Card:highlight (Tumbler)
[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = 'self.highlighted = is_higlighted'
position = 'after'
match_indent = true
payload = '''
if G.jokers ~= nil and next(SMODS.find_card('j_aij_tumbler')) then
    SMODS.calculate_context({aij_card_highlight = true})
end
'''